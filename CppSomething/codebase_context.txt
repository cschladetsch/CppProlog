#include "repl.hpp"
#include "parser.hpp"
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <format>

#ifdef _WIN32
#include <windows.h>
#include <io.h>
#define isatty _isatty
#define fileno _fileno
#else
#include <unistd.h>
#include <sys/ioctl.h>
#endif

namespace logicpp {

// REPLInputParser implementation
REPLInput REPLInputParser::parse(const std::string& input) {
    std::string trimmed = trim(input);
    
    if (trimmed.empty()) {
        return REPLInput("Empty input");
    }
    
    REPLCommand cmd = classify_input(trimmed);
    
    switch (cmd) {
        case REPLCommand::HELP:
        case REPLCommand::QUIT:
        case REPLCommand::CLEAR:
        case REPLCommand::STATS:
            return REPLInput(cmd, "");
            
        case REPLCommand::LOAD:
        case REPLCommand::SAVE:
        case REPLCommand::TRACE: {
            size_t space_pos = trimmed.find(' ');
            if (space_pos == std::string::npos) {
                return REPLInput("Command requires an argument");
            }
            std::string args = trim(trimmed.substr(space_pos + 1));
            return REPLInput(cmd, args);
        }
        
        case REPLCommand::QUERY:
        case REPLCommand::FACT:
        case REPLCommand::RULE:
        case REPLCommand::TYPE:
        case REPLCommand::FUNCTION:
            return REPLInput(cmd, trimmed);
            
        default:
            return REPLInput("Unknown command");
    }
}

REPLCommand REPLInputParser::classify_input(const std::string& input) {
    if (input.starts_with(":help")) return REPLCommand::HELP;
    if (input.starts_with(":quit") || input.starts_with(":q")) return REPLCommand::QUIT;
    if (input.starts_with(":load")) return REPLCommand::LOAD;
    if (input.starts_with(":save")) return REPLCommand::SAVE;
    if (input.starts_with(":clear")) return REPLCommand::CLEAR;
    if (input.starts_with(":trace")) return REPLCommand::TRACE;
    if (input.starts_with(":stats")) return REPLCommand::STATS;
    
    if (input.starts_with("?-")) return REPLCommand::QUERY;
    if (input.starts_with("fact ")) return REPLCommand::FACT;
    if (input.starts_with("rule ")) return REPLCommand::RULE;
    if (input.starts_with("type ")) return REPLCommand::TYPE;
    if (input.starts_with("fn ")) return REPLCommand::FUNCTION;
    
    // Try to detect implicit fact (compound term ending with .)
    if (input.ends_with(".") && input.find(":-") == std::string::npos) {
        return REPLCommand::FACT;
    }
    
    return REPLCommand::UNKNOWN;
}

std::string REPLInputParser::trim(const std::string& str) {
    size_t start = str.find_first_not_of(" \t\n\r");
    if (start == std::string::npos) return "";
    
    size_t end = str.find_last_not_of(" \t\n\r");
    return str.substr(start, end - start + 1);
}

// REPL implementation
REPL::REPL() {
    state.resolver_options.trace_execution = state.tracing_enabled;
    query_engine.set_resolver_options(state.resolver_options);
}

void REPL::run() {
    if (repl_utils::is_interactive_terminal()) {
        run_interactive();
    } else {
        // Non-interactive mode - read from stdin
        std::string line;
        while (std::getline(std::cin, line)) {
            execute_command(line);
        }
    }
}

void REPL::run_interactive() {
    print_welcome();
    running = true;
    
    repl_utils::InputHistory history;
    
    while (running) {
        print_prompt();
        
        std::string input = read_multiline_input();
        
        if (input.empty()) continue;
        
        history.add(input);
        
        auto parsed_input = REPLInputParser::parse(input);
        
        if (!parsed_input.valid) {
            print_error(parsed_input.error_message);
            continue;
        }
        
        try {
            switch (parsed_input.command) {
                case REPLCommand::QUERY:
                    handle_query(parsed_input.content);
                    break;
                    
                case REPLCommand::FACT:
                    handle_fact(parsed_input.content);
                    break;
                    
                case REPLCommand::RULE:
                    handle_rule(parsed_input.content);
                    break;
                    
                case REPLCommand::TYPE:
                    handle_type(parsed_input.content);
                    break;
                    
                case REPLCommand::HELP:
                    handle_help();
                    break;
                    
                case REPLCommand::LOAD:
                    handle_load(parsed_input.content);
                    break;
                    
                case REPLCommand::SAVE:
                    handle_save(parsed_input.content);
                    break;
                    
                case REPLCommand::CLEAR:
                    handle_clear();
                    break;
                    
                case REPLCommand::TRACE:
                    handle_trace(parsed_input.content);
                    break;
                    
                case REPLCommand::STATS:
                    handle_stats();
                    break;
                    
                case REPLCommand::QUIT:
                    running = false;
                    std::cout << "Goodbye!\n";
                    break;
                    
                default:
                    print_error("Unknown command");
                    break;
            }
        } catch (const std::exception& e) {
            print_error(repl_utils::format_error(e));
        }
    }
}

void REPL::handle_query(const std::string& query) {
    state.last_query = query;
    state.query_count++;
    
    auto solutions = query_engine.query(query);
    print_solutions(solutions);
}

void REPL::handle_fact(const std::string& fact_str) {
    auto parse_result = Parser::parse_source(fact_str);
    
    if (!parse_result) {
        print_error("Parse error in fact");
        return;
    }
    
    auto& program = *parse_result.value();
    
    for (auto& clause : program.clauses) {
        if (auto fact = dynamic_cast<ast::Fact*>(clause.get())) {
            // Release ownership from program
            clause.release();
            auto fact_ptr = std::unique_ptr<ast::Fact>(fact);
            query_engine.add_fact(std::move(fact_ptr));
            print_info("Fact added successfully");
        }
    }
}

void REPL::handle_rule(const std::string& rule_str) {
    auto parse_result = Parser::parse_source(rule_str);
    
    if (!parse_result) {
        print_error("Parse error in rule");
        return;
    }
    
    auto& program = *parse_result.value();
    
    for (auto& clause : program.clauses) {
        if (auto rule = dynamic_cast<ast::Rule*>(clause.get())) {
            clause.release();
            auto rule_ptr = std::unique_ptr<ast::Rule>(rule);
            query_engine.add_rule(std::move(rule_ptr));
            print_info("Rule added successfully");
        }
    }
}

void REPL::handle_type(const std::string& type_str) {
    auto parse_result = Parser::parse_source(type_str);
    
    if (!parse_result) {
        print_error("Parse error in type definition");
        return;
    }
    
    print_info("Type definition processed");
}

void REPL::handle_help() {
    std::cout << repl_utils::colorize("LogicPP REPL Help", repl_utils::Color::CYAN) << "\n\n";
    
    std::cout << "Commands:\n";
    std::cout << "  ?- goal.                Query a goal\n";
    std::cout << "  fact predicate(args).   Add a fact\n";
    std::cout << "  rule head :- body.      Add a rule\n";
    std::cout << "  type Name = Type.       Define a type\n";
    std::cout << "\n";
    
    std::cout << "REPL Commands:\n";
    std::cout << "  :help                   Show this help\n";
    std::cout << "  :quit, :q               Exit the REPL\n";
    std::cout << "  :load <file>            Load program from file\n";
    std::cout << "  :save <file>            Save knowledge base to file\n";
    std::cout << "  :clear                  Clear knowledge base\n";
    std::cout << "  :trace on|off           Enable/disable tracing\n";
    std::cout << "  :stats                  Show statistics\n";
    std::cout << "\n";
    
    std::cout << "Example:\n";
    std::cout << "  fact parent(john, mary).\n";
    std::cout << "  rule ancestor(X, Y) :- parent(X, Y).\n";
    std::cout << "  ?- ancestor(john, Who).\n\n";
}

void REPL::handle_load(const std::string& filename) {
    if (load_program_file(filename)) {
        print_info(std::format("Loaded program from {}", filename));
    } else {
        print_error(std::format("Failed to load {}", filename));
    }
}

void REPL::handle_save(const std::string& filename) {
    if (save_knowledge_base(filename)) {
        print_info(std::format("Saved knowledge base to {}", filename));
    } else {
        print_error(std::format("Failed to save to {}", filename));
    }
}

void REPL::handle_clear() {
    query_engine.clear();
    state.query_count = 0;
    print_info("Knowledge base cleared");
}

void REPL::handle_trace(const std::string& args) {
    if (args == "on" || args == "true") {
        enable_tracing(true);
        print_info("Tracing enabled");
    } else if (args == "off" || args == "false") {
        enable_tracing(false);
        print_info("Tracing disabled");
    } else {
        print_error("Usage: :trace on|off");
    }
}

void REPL::handle_stats() {
    auto stats = query_engine.get_stats();
    
    std::cout << repl_utils::colorize("Statistics:", repl_utils::Color::CYAN) << "\n";
    std::cout << std::format("  Facts: {}\n", stats.facts);
    std::cout << std::format("  Rules: {}\n", stats.rules);
    std::cout << std::format("  Total clauses: {}\n", stats.total_clauses());
    std::cout << std::format("  Queries executed: {}\n", state.query_count);
    std::cout << "\n";
}

void REPL::print_welcome() {
    std::cout << repl_utils::colorize("Welcome to LogicPP v1.0", repl_utils::Color::GREEN) << "\n";
    std::cout << "A modern logic programming language with types and pattern matching.\n";
    std::cout << "Type :help for help, :quit to exit.\n\n";
}

void REPL::print_prompt() {
    std::cout << repl_utils::colorize("?- ", repl_utils::Color::BLUE);
}

void REPL::print_solutions(const std::vector<Solution>& solutions) {
    if (solutions.empty()) {
        std::cout << repl_utils::colorize("false", repl_utils::Color::RED) << ".\n";
    } else {
        for (size_t i = 0; i < solutions.size(); ++i) {
            if (solutions.size() > 1) {
                std::cout << repl_utils::colorize(
                    std::format("Solution {}:", i + 1), 
                    repl_utils::Color::CYAN) << " ";
            }
            
            std::string solution_str = solutions[i].to_string();
            std::cout << repl_utils::colorize(solution_str, repl_utils::Color::GREEN) << std::endl;
        }
    }
    std::cout << std::endl;
}

void REPL::print_error(const std::string& message) {
    std::cout << repl_utils::colorize("Error: ", repl_utils::Color::RED) << message << "\n\n";
}

void REPL::print_info(const std::string& message) {
    std::cout << repl_utils::colorize(message, repl_utils::Color::GREEN) << "\n\n";
}

std::string REPL::read_multiline_input() {
    std::string input;
    std::string line;
    
    while (std::getline(std::cin, line)) {
        input += line;
        
        if (is_complete_statement(input)) {
            break;
        }
        
        input += "\n";
        std::cout << "   "; // Continuation prompt
    }
    
    return input;
}

bool REPL::is_complete_statement(const std::string& input) {
    // Simple heuristic: statement is complete if it ends with '.' and brackets are balanced
    if (!input.ends_with(".")) {
        return false;
    }
    
    int paren_count = 0;
    int brace_count = 0;
    int bracket_count = 0;
    
    for (char ch : input) {
        switch (ch) {
            case '(': paren_count++; break;
            case ')': paren_count--; break;
            case '{': brace_count++; break;
            case '}': brace_count--; break;
            case '[': bracket_count++; break;
            case ']': bracket_count--; break;
        }
    }
    
    return paren_count == 0 && brace_count == 0 && bracket_count == 0;
}

bool REPL::load_program_file(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    std::string content((std::istreambuf_iterator<char>(file)),
                       std::istreambuf_iterator<char>());
    
    auto parse_result = Parser::parse_source(content);
    if (!parse_result) {
        return false;
    }
    
    query_engine.load_program(**parse_result);
    return true;
}

bool REPL::save_knowledge_base(const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    // This would need to serialize the knowledge base
    // For now, just write a comment
    file << "% LogicPP Knowledge Base\n";
    file << "% Generated by REPL\n\n";
    
    return true;
}

void REPL::enable_tracing(bool enabled) {
    state.tracing_enabled = enabled;
    state.resolver_options.trace_execution = enabled;
    query_engine.set_resolver_options(state.resolver_options);
}

// REPL utilities implementation
namespace repl_utils {

std::string format_solutions(const std::vector<Solution>& solutions) {
    if (solutions.empty()) {
        return "false";
    }
    
    std::ostringstream oss;
    for (size_t i = 0; i < solutions.size(); ++i) {
        if (i > 0) oss << "; ";
        oss << solutions[i].to_string();
    }
    
    return oss.str();
}

std::string format_error(const std::exception& e, const std::string& context) {
    if (context.empty()) {
        return e.what();
    }
    return std::format("{}: {}", context, e.what());
}

bool is_interactive_terminal() {
#ifdef _WIN32
    return _isatty(_fileno(stdin)) && _isatty(_fileno(stdout));
#else
    return isatty(STDIN_FILENO) && isatty(STDOUT_FILENO);
#endif
}

size_t get_terminal_width() {
#ifdef _WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
    return csbi.srWindow.Right - csbi.srWindow.Left + 1;
#else
    struct winsize w;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0) {
        return w.ws_col;
    }
    return 80; // Default
#endif
}

std::string colorize(const std::string& text, Color color) {
    if (!is_interactive_terminal()) {
        return text; // No colors in non-interactive mode
    }
    
    const char* color_code = "";
    
    switch (color) {
        case Color::RESET:   color_code = "\033[0m"; break;
        case Color::RED:     color_code = "\033[31m"; break;
        case Color::GREEN:   color_code = "\033[32m"; break;
        case Color::YELLOW:  color_code = "\033[33m"; break;
        case Color::BLUE:    color_code = "\033[34m"; break;
        case Color::MAGENTA: color_code = "\033[35m"; break;
        case Color::CYAN:    color_code = "\033[36m"; break;
    }
    
    return std::format("{}{}\033[0m", color_code, text);
}

// InputHistory implementation
void InputHistory::add(const std::string& input) {
    if (input.empty() || (history.size() > 0 && history.back() == input)) {
        return; // Don't add empty or duplicate entries
    }
    
    history.push_back(input);
    
    if (history.size() > max_size) {
        history.erase(history.begin());
    }
    
    reset_position();
}

std::string InputHistory::get_previous() {
    if (history.empty()) return "";
    
    if (current_position > 0) {
        current_position--;
    }
    
    return history[current_position];
}

std::string InputHistory::get_next() {
    if (history.empty()) return "";
    
    if (current_position < history.size() - 1) {
        current_position++;
        return history[current_position];
    }
    
    reset_position();
    return "";
}

void InputHistory::reset_position() {
    current_position = history.size();
}

} // namespace repl_utils

// REPLApplication implementation
int REPLApplication::run() {
    if (options.trace) {
        repl.enable_tracing(true);
    }
    
    repl.set_resolver_options(options.resolver_options);
    
    if (!options.input_file.empty()) {
        repl.execute_file(options.input_file);
    } else {
        repl.run();
    }
    
    return 0;
}

REPLOptions REPLOptions::parse_args(int argc, char* argv[]) {
    REPLOptions options;
    
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        
        if (arg == "--help" || arg == "-h") {
            options.print_help();
            std::exit(0);
        } else if (arg == "--trace") {
            options.trace = true;
        } else if (arg == "--no-typecheck") {
            options.type_check = false;
        } else if (arg == "--file" || arg == "-f") {
            if (i + 1 < argc) {
                options.input_file = argv[++i];
                options.interactive = false;
            }
        }
    }
    
    return options;
}

void REPLOptions::print_help() {
    std::cout << "LogicPP - Modern Logic Programming Language\n\n";
    std::cout << "Usage: logicpp [options] [file]\n\n";
    std::cout << "Options:\n";
    std::cout << "  -h, --help          Show this help message\n";
    std::cout << "  -f, --file FILE     Execute program from file\n";
    std::cout << "  --trace             Enable execution tracing\n";
    std::cout << "  --no-typecheck      Disable type checking\n";
    std::cout << "\n";
}

int REPLApplication::main(int argc, char* argv[]) {
    try {
        auto options = REPLOptions::parse_args(argc, argv);
        REPLApplication app(options);
        return app.run();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}

} // namespace logicpp#include "parser.hpp"
#include <format>
#include <algorithm>

namespace logicpp {

const Token& Parser::peek(size_t offset) const {
    const size_t index = current_token + offset;
    return (index < tokens.size()) ? tokens[index] : tokens.back();
}

const Token& Parser::advance() {
    if (!at_end()) current_token++;
    return tokens[current_token - 1];
}

bool Parser::check(TokenType type) const {
    return !at_end() && peek().type == type;
}

bool Parser::match(TokenType type) {
    if (check(type)) {
        advance();
        return true;
    }
    return false;
}

bool Parser::match(std::initializer_list<TokenType> types) {
    for (TokenType type : types) {
        if (check(type)) {
            advance();
            return true;
        }
    }
    return false;
}

const Token& Parser::consume(TokenType type, const std::string& error_msg) {
    if (check(type)) return advance();
    error(error_msg);
}

bool Parser::at_end() const {
    return current_token >= tokens.size() || peek().type == TokenType::EOF_TOKEN;
}

void Parser::synchronize() {
    advance();
    
    while (!at_end()) {
        if (tokens[current_token - 1].type == TokenType::DOT ||
            tokens[current_token - 1].type == TokenType::NEWLINE) {
            return;
        }
        
        switch (peek().type) {
            case TokenType::FACT:
            case TokenType::RULE:
            case TokenType::QUERY_OP:
            case TokenType::TYPE:
            case TokenType::FN:
                return;
            default:
                break;
        }
        
        advance();
    }
}

[[noreturn]] void Parser::error(const std::string& message) {
    Position pos = at_end() ? tokens.back().position : peek().position;
    throw ParseError(message, pos);
}

std::expected<std::unique_ptr<ast::Program>, ParseError> Parser::parse() {
    try {
        return parse_program();
    } catch (const ParseError& e) {
        return std::unexpected(e);
    }
}

std::unique_ptr<ast::Program> Parser::parse_program() {
    auto program = std::make_unique<ast::Program>(Position{});
    
    while (!at_end()) {
        // Skip newlines
        if (match(TokenType::NEWLINE)) continue;
        
        try {
            if (check(TokenType::TYPE)) {
                program->type_definitions.push_back(parse_type_definition());
            } else if (check(TokenType::FN)) {
                program->functions.push_back(parse_function());
            } else {
                program->clauses.push_back(parse_clause());
            }
        } catch (const ParseError&) {
            synchronize();
            // Continue parsing after error
        }
    }
    
    return program;
}

std::unique_ptr<ast::Clause> Parser::parse_clause() {
    if (check(TokenType::QUERY_OP)) {
        return parse_query();
    } else if (check(TokenType::FACT)) {
        return parse_fact();
    } else if (check(TokenType::RULE)) {
        return parse_rule();
    } else {
        // Try to parse as implicit fact
        auto compound = parse_compound();
        consume(TokenType::DOT, "Expected '.' after fact");
        
        return std::make_unique<ast::Fact>(compound->position, std::move(compound));
    }
}

std::unique_ptr<ast::Fact> Parser::parse_fact() {
    const Token& fact_token = consume(TokenType::FACT, "Expected 'fact'");
    auto compound = parse_compound();
    consume(TokenType::DOT, "Expected '.' after fact");
    
    return std::make_unique<ast::Fact>(fact_token.position, std::move(compound));
}

std::unique_ptr<ast::Rule> Parser::parse_rule() {
    const Token& rule_token = consume(TokenType::RULE, "Expected 'rule'");
    auto head = parse_compound();
    consume(TokenType::RULE_OP, "Expected ':-' after rule head");
    
    auto rule = std::make_unique<ast::Rule>(rule_token.position, std::move(head));
    
    // Parse body expressions
    do {
        rule->body.push_back(parse_expression());
    } while (match(TokenType::COMMA));
    
    // Parse optional WHERE clause
    if (match(TokenType::WHERE)) {
        rule->conditions = parse_where_clause();
    }
    
    consume(TokenType::DOT, "Expected '.' after rule");
    
    return rule;
}

std::unique_ptr<ast::Query> Parser::parse_query() {
    const Token& query_token = consume(TokenType::QUERY_OP, "Expected '?-'");
    auto query = std::make_unique<ast::Query>(query_token.position);
    
    do {
        query->goals.push_back(parse_expression());
    } while (match(TokenType::COMMA));
    
    // Parse optional WHERE clause
    if (match(TokenType::WHERE)) {
        query->conditions = parse_where_clause();
    }
    
    consume(TokenType::DOT, "Expected '.' after query");
    
    return query;
}

std::unique_ptr<ast::Expression> Parser::parse_expression() {
    return parse_logical_or();
}

std::unique_ptr<ast::Expression> Parser::parse_logical_or() {
    // For now, just delegate to logical_and
    // TODO: Implement logical OR when we add it to the language
    return parse_logical_and();
}

std::unique_ptr<ast::Expression> Parser::parse_logical_and() {
    // For now, just delegate to equality
    // TODO: Implement logical AND when we add it to the language
    return parse_equality();
}

std::unique_ptr<ast::Expression> Parser::parse_equality() {
    auto expr = parse_comparison();
    
    while (match({TokenType::EQUAL, TokenType::NOT_EQUAL})) {
        const Token& operator_token = tokens[current_token - 1];
        auto right = parse_comparison();
        
        ast::ComparisonExpr::Op op = (operator_token.type == TokenType::EQUAL) 
            ? ast::ComparisonExpr::Op::EQUAL 
            : ast::ComparisonExpr::Op::NOT_EQUAL;
        
        // Convert expressions to terms if needed
        // This is a simplified approach - real implementation would be more sophisticated
        error("Complex equality expressions not yet implemented");
    }
    
    return expr;
}

std::unique_ptr<ast::Expression> Parser::parse_comparison() {
    auto expr = parse_unification();
    
    while (match({TokenType::LESS, TokenType::GREATER, 
                  TokenType::LESS_EQUAL, TokenType::GREATER_EQUAL})) {
        const Token& operator_token = tokens[current_token - 1];
        auto right = parse_unification();
        
        // Convert to comparison expression
        // Simplified for now
        error("Complex comparison expressions not yet implemented");
    }
    
    return expr;
}

std::unique_ptr<ast::Expression> Parser::parse_unification() {
    return parse_primary_expression();
}

std::unique_ptr<ast::Expression> Parser::parse_primary_expression() {
    // Try to parse as compound (predicate call)
    if (check(TokenType::IDENTIFIER)) {
        auto compound = parse_compound();
        return std::make_unique<ast::CallExpr>(compound->position, std::move(compound));
    }
    
    error("Expected expression");
}

std::unique_ptr<ast::Term> Parser::parse_term() {
    if (check(TokenType::IDENTIFIER)) {
        // Could be atom or compound
        if (peek(1).type == TokenType::LPAREN) {
            return parse_compound();
        } else {
            return parse_atom();
        }
    } else if (check(TokenType::UNDERSCORE) || 
               (check(TokenType::IDENTIFIER) && std::isupper(peek().value[0]))) {
        return parse_variable();
    } else if (check(TokenType::INTEGER) || check(TokenType::FLOAT)) {
        return parse_number();
    } else if (check(TokenType::STRING)) {
        return parse_string();
    }
    
    error("Expected term");
}

std::unique_ptr<ast::Compound> Parser::parse_compound() {
    const Token& name_token = consume(TokenType::IDENTIFIER, "Expected identifier");
    auto compound = std::make_unique<ast::Compound>(name_token.position, name_token.value);
    
    if (match(TokenType::LPAREN)) {
        if (!check(TokenType::RPAREN)) {
            do {
                compound->arguments.push_back(parse_term());
            } while (match(TokenType::COMMA));
        }
        consume(TokenType::RPAREN, "Expected ')' after arguments");
    }
    
    return compound;
}

std::unique_ptr<ast::Atom> Parser::parse_atom() {
    const Token& token = consume(TokenType::IDENTIFIER, "Expected atom");
    return std::make_unique<ast::Atom>(token.position, token.value);
}

std::unique_ptr<ast::Variable> Parser::parse_variable() {
    if (match(TokenType::UNDERSCORE)) {
        const Token& token = tokens[current_token - 1];
        return std::make_unique<ast::Variable>(token.position, "_");
    }
    
    const Token& token = consume(TokenType::IDENTIFIER, "Expected variable");
    // In our language, variables start with uppercase (Prolog convention)
    if (!std::isupper(token.value[0])) {
        error("Variables must start with uppercase letter");
    }
    
    return std::make_unique<ast::Variable>(token.position, token.value);
}

std::unique_ptr<ast::Number> Parser::parse_number() {
    if (match(TokenType::INTEGER)) {
        const Token& token = tokens[current_token - 1];
        int64_t value = std::stoll(token.value);
        return std::make_unique<ast::Number>(token.position, value);
    }
    
    if (match(TokenType::FLOAT)) {
        const Token& token = tokens[current_token - 1];
        double value = std::stod(token.value);
        return std::make_unique<ast::Number>(token.position, value);
    }
    
    error("Expected number");
}

std::unique_ptr<ast::String> Parser::parse_string() {
    const Token& token = consume(TokenType::STRING, "Expected string");
    return std::make_unique<ast::String>(token.position, token.value);
}

std::unique_ptr<ast::Type> Parser::parse_type() {
    if (match(TokenType::IDENTIFIER)) {
        const Token& token = tokens[current_token - 1];
        
        if (token.value == "atom") {
            return std::make_unique<ast::AtomType>(token.position);
        } else if (token.value == "i32" || token.value == "i64") {
            return std::make_unique<ast::IntegerType>(token.position);
        } else {
            // Compound type
            auto compound_type = std::make_unique<ast::CompoundType>(token.position, token.value);
            
            // Parse generic parameters if present
            if (match(TokenType::LESS)) {
                do {
                    compound_type->parameters.push_back(parse_type());
                } while (match(TokenType::COMMA));
                consume(TokenType::GREATER, "Expected '>' after type parameters");
            }
            
            return compound_type;
        }
    }
    
    error("Expected type");
}

std::unique_ptr<ast::TypeDefinition> Parser::parse_type_definition() {
    const Token& type_token = consume(TokenType::TYPE, "Expected 'type'");
    const Token& name_token = consume(TokenType::IDENTIFIER, "Expected type name");
    consume(TokenType::UNIFY, "Expected '=' after type name");
    
    auto type = parse_type();
    consume(TokenType::DOT, "Expected '.' after type definition");
    
    return std::make_unique<ast::TypeDefinition>(
        type_token.position, name_token.value, std::move(type));
}

std::unique_ptr<ast::Function> Parser::parse_function() {
    const Token& fn_token = consume(TokenType::FN, "Expected 'fn'");
    const Token& name_token = consume(TokenType::IDENTIFIER, "Expected function name");
    
    auto function = std::make_unique<ast::Function>(fn_token.position, name_token.value);
    
    // Parse parameters
    consume(TokenType::LPAREN, "Expected '(' after function name");
    if (!check(TokenType::RPAREN)) {
        do {
            const Token& param_name = consume(TokenType::IDENTIFIER, "Expected parameter name");
            consume(TokenType::COLON, "Expected ':' after parameter name");
            auto param_type = parse_type();
            
            function->parameters.emplace_back(param_name.value, std::move(param_type));
        } while (match(TokenType::COMMA));
    }
    consume(TokenType::RPAREN, "Expected ')' after parameters");
    
    // Parse return type
    consume(TokenType::ARROW, "Expected '->' after parameters");
    function->return_type = parse_type();
    
    // Parse body
    consume(TokenType::LBRACE, "Expected '{' after function signature");
    while (!check(TokenType::RBRACE) && !at_end()) {
        function->body.push_back(parse_expression());
        if (!match(TokenType::COMMA)) break;
    }
    consume(TokenType::RBRACE, "Expected '}' after function body");
    
    return function;
}

std::vector<std::unique_ptr<ast::Expression>> Parser::parse_where_clause() {
    std::vector<std::unique_ptr<ast::Expression>> conditions;
    
    do {
        conditions.push_back(parse_expression());
    } while (match(TokenType::COMMA));
    
    return conditions;
}

// Static utility method
std::expected<std::unique_ptr<ast::Program>, ParseError> 
Parser::parse_source(std::string_view source) {
    Lexer lexer(source);
    auto tokens = lexer.tokenize();
    
    Parser parser(std::move(tokens));
    return parser.parse();
}

} // namespace logicpp#pragma once

#include "resolver.hpp"
#include "type_system.hpp"
#include <string>
#include <vector>
#include <memory>
#include <iostream>
#include <sstream>

namespace logicpp {

// REPL command types
enum class REPLCommand {
    QUERY,          // ?- goal.
    FACT,           // fact declaration
    RULE,           // rule declaration
    TYPE,           // type definition
    FUNCTION,       // function definition
    HELP,           // :help
    QUIT,           // :quit
    LOAD,           // :load filename
    SAVE,           // :save filename
    CLEAR,          // :clear
    TRACE,          // :trace on/off
    STATS,          // :stats
    UNKNOWN
};

// REPL command parser
struct REPLInput {
    REPLCommand command;
    std::string content;
    bool valid;
    std::string error_message;
    
    REPLInput(REPLCommand cmd, std::string cont) 
        : command(cmd), content(std::move(cont)), valid(true) {}
    
    REPLInput(std::string error) 
        : command(REPLCommand::UNKNOWN), valid(false), error_message(std::move(error)) {}
};

class REPLInputParser {
public:
    static REPLInput parse(const std::string& input);
    
private:
    static REPLCommand classify_input(const std::string& input);
    static std::string trim(const std::string& str);
};

// REPL session state
struct REPLState {
    bool tracing_enabled = false;
    ResolverOptions resolver_options;
    std::string last_query;
    size_t query_count = 0;
    
    REPLState() {
        resolver_options = ResolverOptions::default_options();
    }
};

// Main REPL interface
class REPL {
private:
    QueryEngine query_engine;
    TypeChecker type_checker;
    REPLState state;
    bool running = false;
    
    // Command handlers
    void handle_query(const std::string& query);
    void handle_fact(const std::string& fact_str);
    void handle_rule(const std::string& rule_str);
    void handle_type(const std::string& type_str);
    void handle_help();
    void handle_load(const std::string& filename);
    void handle_save(const std::string& filename);
    void handle_clear();
    void handle_trace(const std::string& args);
    void handle_stats();
    
    // Utility methods
    void print_welcome();
    void print_prompt();
    void print_solutions(const std::vector<Solution>& solutions);
    void print_error(const std::string& message);
    void print_info(const std::string& message);
    
    // Input handling
    std::string read_multiline_input();
    bool is_complete_statement(const std::string& input);
    
    // File I/O
    bool load_program_file(const std::string& filename);
    bool save_knowledge_base(const std::string& filename);

public:
    REPL();
    
    // Main REPL loop
    void run();
    void run_interactive();
    
    // Non-interactive mode
    void execute_command(const std::string& command);
    void execute_file(const std::string& filename);
    
    // Configuration
    void set_resolver_options(const ResolverOptions& options);
    void enable_tracing(bool enabled);
    
    // Batch mode
    std::vector<std::string> execute_batch(const std::vector<std::string>& commands);
};

// REPL utilities
namespace repl_utils {
    
    // Format solutions for display
    std::string format_solutions(const std::vector<Solution>& solutions);
    
    // Format error messages
    std::string format_error(const std::exception& e, const std::string& context = "");
    
    // Check if running in interactive terminal
    bool is_interactive_terminal();
    
    // Get terminal width for formatting
    size_t get_terminal_width();
    
    // Color output support
    enum class Color { RESET, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN };
    std::string colorize(const std::string& text, Color color);
    
    // Input history management
    class InputHistory {
    private:
        std::vector<std::string> history;
        size_t max_size;
        size_t current_position;
        
    public:
        explicit InputHistory(size_t max_sz = 1000) 
            : max_size(max_sz), current_position(0) {}
        
        void add(const std::string& input);
        std::string get_previous();
        std::string get_next();
        void reset_position();
        
        const std::vector<std::string>& get_history() const { return history; }
        void clear() { history.clear(); current_position = 0; }
        
        // Save/load history to file
        bool save_to_file(const std::string& filename) const;
        bool load_from_file(const std::string& filename);
    };
    
} // namespace repl_utils

// Command-line argument parser for the REPL
struct REPLOptions {
    bool interactive = true;
    std::string input_file;
    std::string output_file;
    bool trace = false;
    bool type_check = true;
    ResolverOptions resolver_options;
    
    static REPLOptions parse_args(int argc, char* argv[]);
    void print_help();
};

// Main entry point for REPL application
class REPLApplication {
private:
    REPLOptions options;
    REPL repl;
    
public:
    explicit REPLApplication(REPLOptions opts) : options(std::move(opts)) {}
    
    int run();
    
    static int main(int argc, char* argv[]);
};

} // namespace logicpp#pragma once

#include <memory>
#include <vector>
#include <string>
#include <variant>
#include <optional>
#include "lexer.hpp"

namespace logicpp::ast {

// Forward declarations
struct Expression;
struct Term;
struct Atom;
struct Variable;
struct Compound;
struct Number;
struct String;

// Base AST node
struct ASTNode {
    Position position;
    virtual ~ASTNode() = default;
    
protected:
    ASTNode(Position pos) : position(pos) {}
};

// Type system
struct Type : ASTNode {
    Type(Position pos) : ASTNode(pos) {}
};

struct AtomType : Type {
    AtomType(Position pos) : Type(pos) {}
};

struct IntegerType : Type {
    IntegerType(Position pos) : Type(pos) {}
};

struct CompoundType : Type {
    std::string name;
    std::vector<std::unique_ptr<Type>> parameters;
    
    CompoundType(Position pos, std::string n) 
        : Type(pos), name(std::move(n)) {}
};

// Terms
struct Term : ASTNode {
    std::optional<std::unique_ptr<Type>> type_annotation;
    
    Term(Position pos) : ASTNode(pos) {}
};

struct Atom : Term {
    std::string value;
    
    Atom(Position pos, std::string v) 
        : Term(pos), value(std::move(v)) {}
};

struct Variable : Term {
    std::string name;
    
    Variable(Position pos, std::string n) 
        : Term(pos), name(std::move(n)) {}
};

struct Number : Term {
    std::variant<int64_t, double> value;
    
    Number(Position pos, int64_t v) 
        : Term(pos), value(v) {}
    Number(Position pos, double v) 
        : Term(pos), value(v) {}
};

struct String : Term {
    std::string value;
    
    String(Position pos, std::string v) 
        : Term(pos), value(std::move(v)) {}
};

struct Compound : Term {
    std::string functor;
    std::vector<std::unique_ptr<Term>> arguments;
    
    Compound(Position pos, std::string f) 
        : Term(pos), functor(std::move(f)) {}
};

// Expressions and conditions
struct Expression : ASTNode {
    Expression(Position pos) : ASTNode(pos) {}
};

struct UnificationExpr : Expression {
    std::unique_ptr<Term> left;
    std::unique_ptr<Term> right;
    
    UnificationExpr(Position pos, std::unique_ptr<Term> l, std::unique_ptr<Term> r)
        : Expression(pos), left(std::move(l)), right(std::move(r)) {}
};

struct ComparisonExpr : Expression {
    enum class Op { EQUAL, NOT_EQUAL, LESS, GREATER, LESS_EQUAL, GREATER_EQUAL };
    
    std::unique_ptr<Term> left;
    std::unique_ptr<Term> right;
    Op operation;
    
    ComparisonExpr(Position pos, std::unique_ptr<Term> l, std::unique_ptr<Term> r, Op op)
        : Expression(pos), left(std::move(l)), right(std::move(r)), operation(op) {}
};

struct CallExpr : Expression {
    std::unique_ptr<Compound> compound;
    
    CallExpr(Position pos, std::unique_ptr<Compound> c)
        : Expression(pos), compound(std::move(c)) {}
};

// Clauses
struct Clause : ASTNode {
    Clause(Position pos) : ASTNode(pos) {}
};

struct Fact : Clause {
    std::unique_ptr<Compound> head;
    
    Fact(Position pos, std::unique_ptr<Compound> h)
        : Clause(pos), head(std::move(h)) {}
};

struct Rule : Clause {
    std::unique_ptr<Compound> head;
    std::vector<std::unique_ptr<Expression>> body;
    std::vector<std::unique_ptr<Expression>> conditions; // WHERE clause
    
    Rule(Position pos, std::unique_ptr<Compound> h)
        : Clause(pos), head(std::move(h)) {}
};

struct Query : Clause {
    std::vector<std::unique_ptr<Expression>> goals;
    std::vector<std::unique_ptr<Expression>> conditions; // WHERE clause
    
    Query(Position pos) : Clause(pos) {}
};

// Type definitions
struct TypeDefinition : ASTNode {
    std::string name;
    std::unique_ptr<Type> type;
    
    TypeDefinition(Position pos, std::string n, std::unique_ptr<Type> t)
        : ASTNode(pos), name(std::move(n)), type(std::move(t)) {}
};

// Function definitions (first-class functions)
struct Function : ASTNode {
    std::string name;
    std::vector<std::pair<std::string, std::unique_ptr<Type>>> parameters;
    std::unique_ptr<Type> return_type;
    std::vector<std::unique_ptr<Expression>> body;
    
    Function(Position pos, std::string n)
        : ASTNode(pos), name(std::move(n)) {}
};

// Pattern matching
struct Pattern : ASTNode {
    Pattern(Position pos) : ASTNode(pos) {}
};

struct MatchExpr : Expression {
    std::unique_ptr<Term> target;
    std::vector<std::pair<std::unique_ptr<Pattern>, std::vector<std::unique_ptr<Expression>>>> arms;
    
    MatchExpr(Position pos, std::unique_ptr<Term> t)
        : Expression(pos), target(std::move(t)) {}
};

// Program structure
struct Program : ASTNode {
    std::vector<std::unique_ptr<Clause>> clauses;
    std::vector<std::unique_ptr<TypeDefinition>> type_definitions;
    std::vector<std::unique_ptr<Function>> functions;
    
    Program(Position pos) : ASTNode(pos) {}
};

// Visitor pattern for AST traversal
template<typename T>
class ASTVisitor {
public:
    virtual ~ASTVisitor() = default;
    
    virtual T visit_program(const Program& node) = 0;
    virtual T visit_fact(const Fact& node) = 0;
    virtual T visit_rule(const Rule& node) = 0;
    virtual T visit_query(const Query& node) = 0;
    virtual T visit_atom(const Atom& node) = 0;
    virtual T visit_variable(const Variable& node) = 0;
    virtual T visit_compound(const Compound& node) = 0;
    virtual T visit_number(const Number& node) = 0;
    virtual T visit_string(const String& node) = 0;
    virtual T visit_unification(const UnificationExpr& node) = 0;
    virtual T visit_comparison(const ComparisonExpr& node) = 0;
    virtual T visit_call(const CallExpr& node) = 0;
    virtual T visit_match(const MatchExpr& node) = 0;
};

} // namespace logicpp::ast#include "unification.hpp"
#include <format>
#include <sstream>
#include <atomic>

namespace logicpp {

// Substitution implementation
Substitution::Substitution(const Substitution& other) {
    for (const auto& [var, term] : other.bindings) {
        bindings[var] = term_utils::deep_copy(*term);
    }
}

Substitution& Substitution::operator=(const Substitution& other) {
    if (this != &other) {
        bindings.clear();
        for (const auto& [var, term] : other.bindings) {
            bindings[var] = term_utils::deep_copy(*term);
        }
    }
    return *this;
}

void Substitution::bind(const std::string& variable, std::unique_ptr<ast::Term> term) {
    bindings[variable] = std::move(term);
}

const ast::Term* Substitution::lookup(const std::string& variable) const {
    auto it = bindings.find(variable);
    return (it != bindings.end()) ? it->second.get() : nullptr;
}

bool Substitution::is_bound(const std::string& variable) const {
    return bindings.find(variable) != bindings.end();
}

std::unique_ptr<ast::Term> Substitution::apply(const ast::Term& term) const {
    if (auto var = dynamic_cast<const ast::Variable*>(&term)) {
        if (auto bound_term = lookup(var->name)) {
            // Recursively apply substitution to avoid chains
            return apply(*bound_term);
        }
        return term_utils::deep_copy(term);
    }
    
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        auto new_compound = std::make_unique<ast::Compound>(
            compound->position, compound->functor);
        
        for (const auto& arg : compound->arguments) {
            new_compound->arguments.push_back(apply(*arg));
        }
        
        return std::move(new_compound);
    }
    
    // For atoms, numbers, strings - just copy
    return term_utils::deep_copy(term);
}

Substitution Substitution::compose(const Substitution& other) const {
    Substitution result = *this;
    
    // Apply this substitution to other's bindings and add them
    for (const auto& [var, term] : other.bindings) {
        if (!result.is_bound(var)) {
            result.bind(var, apply(*term));
        }
    }
    
    // Apply other's substitution to our existing bindings
    for (auto& [var, term] : result.bindings) {
        term = other.apply(*term);
    }
    
    return result;
}

std::vector<std::string> Substitution::variables() const {
    std::vector<std::string> vars;
    vars.reserve(bindings.size());
    
    for (const auto& [var, _] : bindings) {
        vars.push_back(var);
    }
    
    return vars;
}

std::string Substitution::to_string() const {
    if (bindings.empty()) return "{}";
    
    std::ostringstream oss;
    oss << "{ ";
    bool first = true;
    
    for (const auto& [var, term] : bindings) {
        if (!first) oss << ", ";
        oss << var << " -> " << term_utils::term_to_string(*term);
        first = false;
    }
    
    oss << " }";
    return oss.str();
}

// UnificationEngine implementation
UnificationResult UnificationEngine::unify(const ast::Term& term1, const ast::Term& term2) const {
    Substitution substitution;
    return unify(term1, term2, substitution);
}

UnificationResult UnificationEngine::unify(
    const ast::Term& term1, 
    const ast::Term& term2,
    const Substitution& existing_substitution) const {
    
    Substitution substitution = existing_substitution;
    
    // Apply existing substitution first
    auto applied_term1 = substitution.apply(term1);
    auto applied_term2 = substitution.apply(term2);
    
    // Recursively unify the applied terms
    if (auto var1 = dynamic_cast<const ast::Variable*>(applied_term1.get())) {
        if (auto var2 = dynamic_cast<const ast::Variable*>(applied_term2.get())) {
            return unify_variables(*var1, *var2, substitution);
        } else {
            return unify_variable_with_term(*var1, *applied_term2, substitution);
        }
    }
    
    if (auto var2 = dynamic_cast<const ast::Variable*>(applied_term2.get())) {
        return unify_variable_with_term(*var2, *applied_term1, substitution);
    }
    
    // Handle other cases similar to unify_internal logic
    if (auto comp1 = dynamic_cast<const ast::Compound*>(applied_term1.get())) {
        if (auto comp2 = dynamic_cast<const ast::Compound*>(applied_term2.get())) {
            return unify_compounds(*comp1, *comp2, substitution);
        }
        return UnificationResult::failure();
    }
    
    if (auto atom1 = dynamic_cast<const ast::Atom*>(applied_term1.get())) {
        if (auto atom2 = dynamic_cast<const ast::Atom*>(applied_term2.get())) {
            auto result = unify_atoms(*atom1, *atom2);
            if (result.success) {
                result.substitution = std::move(substitution);
            }
            return result;
        }
        return UnificationResult::failure();
    }
    
    // Similar logic for numbers and strings...
    return UnificationResult::failure();
}


UnificationResult UnificationEngine::unify_variables(
    const ast::Variable& var1, 
    const ast::Variable& var2,
    Substitution& substitution) const {
    
    // Anonymous variables unify with anything
    if (var1.name == "_" || var2.name == "_") {
        return UnificationResult::success(std::move(substitution));
    }
    
    // Same variable
    if (var1.name == var2.name) {
        return UnificationResult::success(std::move(substitution));
    }
    
    // Check if either is already bound
    if (const ast::Term* bound1 = substitution.lookup(var1.name)) {
        return unify(*bound1, var2, substitution);
    }
    
    if (const ast::Term* bound2 = substitution.lookup(var2.name)) {
        return unify(var1, *bound2, substitution);
    }
    
    // Bind var1 to var2 (arbitrary choice)
    substitution.bind(var1.name, std::make_unique<ast::Variable>(var2.position, var2.name));
    return UnificationResult::success(std::move(substitution));
}

UnificationResult UnificationEngine::unify_variable_with_term(
    const ast::Variable& variable,
    const ast::Term& term,
    Substitution& substitution) const {
    
    // Anonymous variable unifies with anything
    if (variable.name == "_") {
        return UnificationResult::success(std::move(substitution));
    }
    
    // Check if variable is already bound
    if (const ast::Term* bound_term = substitution.lookup(variable.name)) {
        return unify(*bound_term, term, substitution);
    }
    
    // Occur check to prevent infinite structures
    if (occurs_check(variable.name, term)) {
        return UnificationResult::failure();
    }
    
    // Bind variable to term
    substitution.bind(variable.name, term_utils::deep_copy(term));
    return UnificationResult::success(std::move(substitution));
}

UnificationResult UnificationEngine::unify_compounds(
    const ast::Compound& comp1,
    const ast::Compound& comp2,
    Substitution& substitution) const {
    
    // Different functors
    if (comp1.functor != comp2.functor) {
        return UnificationResult::failure();
    }
    
    // Different arity
    if (comp1.arguments.size() != comp2.arguments.size()) {
        return UnificationResult::failure();
    }
    
    // Unify arguments pairwise
    return unify_lists(comp1.arguments, comp2.arguments, substitution);
}

UnificationResult UnificationEngine::unify_atoms(
    const ast::Atom& atom1,
    const ast::Atom& atom2) const {
    
    if (atom1.value == atom2.value) {
        return UnificationResult::success();
    }
    return UnificationResult::failure();
}

UnificationResult UnificationEngine::unify_numbers(
    const ast::Number& num1,
    const ast::Number& num2) const {
    
    // Handle different number types
    if (std::holds_alternative<int64_t>(num1.value) && 
        std::holds_alternative<int64_t>(num2.value)) {
        if (std::get<int64_t>(num1.value) == std::get<int64_t>(num2.value)) {
            return UnificationResult::success();
        }
    } else if (std::holds_alternative<double>(num1.value) && 
               std::holds_alternative<double>(num2.value)) {
        if (std::get<double>(num1.value) == std::get<double>(num2.value)) {
            return UnificationResult::success();
        }
    }
    // Could add mixed int/double comparison here
    
    return UnificationResult::failure();
}

UnificationResult UnificationEngine::unify_strings(
    const ast::String& str1,
    const ast::String& str2) const {
    
    if (str1.value == str2.value) {
        return UnificationResult::success();
    }
    return UnificationResult::failure();
}

UnificationResult UnificationEngine::unify_lists(
    const std::vector<std::unique_ptr<ast::Term>>& terms1,
    const std::vector<std::unique_ptr<ast::Term>>& terms2,
    Substitution& substitution) const {
    
    if (terms1.size() != terms2.size()) {
        return UnificationResult::failure();
    }
    
    for (size_t i = 0; i < terms1.size(); ++i) {
        auto result = unify(*terms1[i], *terms2[i], substitution);
        if (!result.success) {
            return result;
        }
        substitution = std::move(result.substitution);
    }
    
    return UnificationResult::success(std::move(substitution));
}

bool UnificationEngine::occurs_check(const std::string& variable, const ast::Term& term) const {
    if (auto var = dynamic_cast<const ast::Variable*>(&term)) {
        return var->name == variable;
    }
    
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        for (const auto& arg : compound->arguments) {
            if (occurs_check(variable, *arg)) {
                return true;
            }
        }
    }
    
    return false;
}

bool UnificationEngine::unifiable(const ast::Term& term1, const ast::Term& term2) const {
    return unify(term1, term2).success;
}

std::string UnificationEngine::fresh_variable_name(const std::string& base) const {
    static std::atomic<size_t> counter{0};
    return std::format("{}_{}", base, counter.fetch_add(1));
}

// Term utilities implementation
namespace term_utils {

bool is_variable(const ast::Term& term) {
    return dynamic_cast<const ast::Variable*>(&term) != nullptr;
}

bool is_ground(const ast::Term& term) {
    if (is_variable(term)) {
        return false;
    }
    
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        for (const auto& arg : compound->arguments) {
            if (!is_ground(*arg)) {
                return false;
            }
        }
    }
    
    return true;
}

std::vector<std::string> get_variables(const ast::Term& term) {
    std::vector<std::string> variables;
    
    if (auto var = dynamic_cast<const ast::Variable*>(&term)) {
        if (var->name != "_") {  // Exclude anonymous variables
            variables.push_back(var->name);
        }
    } else if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        for (const auto& arg : compound->arguments) {
            auto arg_vars = get_variables(*arg);
            variables.insert(variables.end(), arg_vars.begin(), arg_vars.end());
        }
    }
    
    // Remove duplicates
    std::sort(variables.begin(), variables.end());
    variables.erase(std::unique(variables.begin(), variables.end()), variables.end());
    
    return variables;
}

std::string term_to_string(const ast::Term& term) {
    if (auto var = dynamic_cast<const ast::Variable*>(&term)) {
        return var->name;
    }
    
    if (auto atom = dynamic_cast<const ast::Atom*>(&term)) {
        return atom->value;
    }
    
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        if (compound->arguments.empty()) {
            return compound->functor;
        }
        
        std::ostringstream oss;
        oss << compound->functor << "(";
        for (size_t i = 0; i < compound->arguments.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << term_to_string(*compound->arguments[i]);
        }
        oss << ")";
        return oss.str();
    }
    
    if (auto number = dynamic_cast<const ast::Number*>(&term)) {
        if (std::holds_alternative<int64_t>(number->value)) {
            return std::to_string(std::get<int64_t>(number->value));
        } else {
            return std::to_string(std::get<double>(number->value));
        }
    }
    
    if (auto str = dynamic_cast<const ast::String*>(&term)) {
        return "\"" + str->value + "\"";
    }
    
    return "<?>";
}

std::unique_ptr<ast::Term> deep_copy(const ast::Term& term) {
    if (auto var = dynamic_cast<const ast::Variable*>(&term)) {
        return std::make_unique<ast::Variable>(var->position, var->name);
    }
    
    if (auto atom = dynamic_cast<const ast::Atom*>(&term)) {
        return std::make_unique<ast::Atom>(atom->position, atom->value);
    }
    
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        auto new_compound = std::make_unique<ast::Compound>(
            compound->position, compound->functor);
        
        for (const auto& arg : compound->arguments) {
            new_compound->arguments.push_back(deep_copy(*arg));
        }
        
        return std::move(new_compound);
    }
    
    if (auto number = dynamic_cast<const ast::Number*>(&term)) {
        if (std::holds_alternative<int64_t>(number->value)) {
            return std::make_unique<ast::Number>(
                number->position, std::get<int64_t>(number->value));
        } else {
            return std::make_unique<ast::Number>(
                number->position, std::get<double>(number->value));
        }
    }
    
    if (auto str = dynamic_cast<const ast::String*>(&term)) {
        return std::make_unique<ast::String>(str->position, str->value);
    }
    
    // Fallback
    return std::make_unique<ast::Atom>(Position{}, "<?>");
}

} // namespace term_utils

} // namespace logicpp#pragma once

#include "ast.hpp"
#include "unification.hpp"
#include <vector>
#include <memory>
#include <functional>
#include <optional>
#include <set>
#include <queue>

namespace logicpp {

// Knowledge base containing facts and rules
class KnowledgeBase {
private:
    std::vector<std::unique_ptr<ast::Fact>> facts;
    std::vector<std::unique_ptr<ast::Rule>> rules;
    
public:
    void add_fact(std::unique_ptr<ast::Fact> fact);
    void add_rule(std::unique_ptr<ast::Rule> rule);
    
    // Get all clauses (facts and rules) that might unify with a goal
    std::vector<const ast::Clause*> get_matching_clauses(const ast::Compound& goal) const;
    
    // Clear all knowledge
    void clear();
    
    // Statistics
    size_t fact_count() const { return facts.size(); }
    size_t rule_count() const { return rules.size(); }
    
    // Debug: print all knowledge
    void print_knowledge() const;
};

// A goal in the resolution process
struct Goal {
    std::unique_ptr<ast::Compound> compound;
    Substitution substitution;
    size_t depth;
    
    Goal(std::unique_ptr<ast::Compound> comp, Substitution sub = {}, size_t d = 0)
        : compound(std::move(comp)), substitution(std::move(sub)), depth(d) {}
};

// Solution to a query
struct Solution {
    Substitution bindings;
    std::vector<std::string> variable_names;  // Original query variables
    
    // Check if solution binds specific variable
    bool binds(const std::string& variable) const;
    
    // Get binding for variable as string
    std::string get_binding_string(const std::string& variable) const;
    
    // Convert to human-readable format
    std::string to_string() const;
};

// Query resolution options
struct ResolverOptions {
    size_t max_depth = 1000;           // Maximum recursion depth
    size_t max_solutions = 100;        // Maximum number of solutions to find
    bool find_all_solutions = false;   // Find all solutions vs first solution
    bool trace_execution = false;      // Enable execution tracing
    
    static ResolverOptions default_options() { return {}; }
    static ResolverOptions find_all() { 
        ResolverOptions opts;
        opts.find_all_solutions = true;
        return opts;
    }
};

// Query resolver using SLD resolution
class QueryResolver {
private:
    const KnowledgeBase& knowledge_base;
    UnificationEngine unification_engine;
    ResolverOptions options;
    
    // Trace execution if enabled
    void trace(const std::string& message, size_t depth = 0) const;
    
    // Resolve a single goal
    void resolve_goal(
        const Goal& goal,
        std::vector<Goal>& remaining_goals,
        std::vector<Solution>& solutions) const;
    
    // Apply substitution to remaining goals
    std::vector<Goal> apply_substitution_to_goals(
        const std::vector<Goal>& goals,
        const Substitution& substitution) const;
    
    // Check if depth limit exceeded
    bool depth_limit_exceeded(size_t depth) const;
    
    // Rename variables in clause to avoid conflicts
    std::unique_ptr<ast::Clause> rename_clause_variables(
        const ast::Clause& clause,
        const std::string& prefix) const;
    
    // Generate unique variable prefix
    std::string generate_variable_prefix() const;

public:
    QueryResolver(const KnowledgeBase& kb, ResolverOptions opts = ResolverOptions::default_options())
        : knowledge_base(kb), options(opts) {}
    
    // Resolve a query and return all solutions
    std::vector<Solution> resolve_query(const ast::Query& query) const;
    
    // Resolve a single compound goal
    std::vector<Solution> resolve_goal(const ast::Compound& goal) const;
    
    // Check if a goal can be proven (returns true/false)
    bool can_prove(const ast::Compound& goal) const;
    
    // Get first solution if any
    std::optional<Solution> get_first_solution(const ast::Compound& goal) const;
    
    // Set resolver options
    void set_options(const ResolverOptions& new_options) { options = new_options; }
    const ResolverOptions& get_options() const { return options; }
};

// Interactive query engine
class QueryEngine {
private:
    KnowledgeBase knowledge_base;
    QueryResolver resolver;
    
public:
    QueryEngine() : resolver(knowledge_base) {}
    
    // Load program into knowledge base
    void load_program(const ast::Program& program);
    
    // Add individual clauses
    void add_fact(std::unique_ptr<ast::Fact> fact);
    void add_rule(std::unique_ptr<ast::Rule> rule);
    
    // Execute query
    std::vector<Solution> query(const std::string& query_string);
    std::vector<Solution> query(const ast::Query& query);
    
    // Quick yes/no queries
    bool ask(const std::string& goal_string);
    bool ask(const ast::Compound& goal);
    
    // Clear knowledge base
    void clear() { knowledge_base.clear(); }
    
    // Get statistics
    struct Stats {
        size_t facts;
        size_t rules;
        size_t total_clauses() const { return facts + rules; }
    };
    Stats get_stats() const;
    
    // Set resolver options
    void set_resolver_options(const ResolverOptions& options) {
        resolver.set_options(options);
    }
};

// Utility functions for working with solutions
namespace solution_utils {
    
    // Print solutions in a readable format
    void print_solutions(const std::vector<Solution>& solutions);
    
    // Check if solutions contain a specific binding
    bool solutions_contain_binding(
        const std::vector<Solution>& solutions,
        const std::string& variable,
        const std::string& value);
    
    // Filter solutions by variable binding
    std::vector<Solution> filter_solutions_by_binding(
        const std::vector<Solution>& solutions,
        const std::string& variable,
        const std::function<bool(const std::string&)>& predicate);
    
} // namespace solution_utils

} // namespace logicpp#include "type_system.hpp"
#include "unification.hpp"
#include <format>
#include <algorithm>

namespace logicpp {

// TypeEnvironment implementation
void TypeEnvironment::set_variable_type(const std::string& var, std::unique_ptr<ast::Type> type) {
    variable_types[var] = std::move(type);
}

const ast::Type* TypeEnvironment::get_variable_type(const std::string& var) const {
    auto it = variable_types.find(var);
    return (it != variable_types.end()) ? it->second.get() : nullptr;
}

bool TypeEnvironment::has_variable_type(const std::string& var) const {
    return variable_types.find(var) != variable_types.end();
}

void TypeEnvironment::set_predicate_signature(const std::string& predicate, 
                                             std::vector<std::unique_ptr<ast::Type>> signature) {
    predicate_types[predicate] = std::move(signature);
}

const std::vector<std::unique_ptr<ast::Type>>* 
TypeEnvironment::get_predicate_signature(const std::string& predicate) const {
    auto it = predicate_types.find(predicate);
    return (it != predicate_types.end()) ? &it->second : nullptr;
}

bool TypeEnvironment::has_predicate_signature(const std::string& predicate) const {
    return predicate_types.find(predicate) != predicate_types.end();
}

std::unique_ptr<TypeEnvironment> TypeEnvironment::create_child() const {
    auto child = std::make_unique<TypeEnvironment>();
    
    // Copy variable types
    for (const auto& [var, type] : variable_types) {
        child->variable_types[var] = type_utils::make_compound_type("copy"); // Simplified
    }
    
    // Copy predicate signatures
    for (const auto& [pred, sig] : predicate_types) {
        std::vector<std::unique_ptr<ast::Type>> sig_copy;
        // Simplified copying
        child->predicate_types[pred] = std::move(sig_copy);
    }
    
    return child;
}

void TypeEnvironment::merge(const TypeEnvironment& other) {
    // Merge variable types
    for (const auto& [var, type] : other.variable_types) {
        if (!has_variable_type(var)) {
            variable_types[var] = type_utils::make_compound_type("merged"); // Simplified
        }
    }
    
    // Merge predicate signatures
    for (const auto& [pred, sig] : other.predicate_types) {
        if (!has_predicate_signature(pred)) {
            std::vector<std::unique_ptr<ast::Type>> sig_copy;
            predicate_types[pred] = std::move(sig_copy);
        }
    }
}

// TypeChecker implementation
TypeChecker::TypeChecker() {
    add_builtin_types();
}

void TypeChecker::add_builtin_types() {
    // Add built-in predicate signatures
    std::vector<std::unique_ptr<ast::Type>> eq_signature;
    eq_signature.push_back(type_utils::make_atom_type());
    eq_signature.push_back(type_utils::make_atom_type());
    global_env.set_predicate_signature("=", std::move(eq_signature));
    
    // Add arithmetic predicates
    std::vector<std::unique_ptr<ast::Type>> arith_signature;
    arith_signature.push_back(type_utils::make_integer_type());
    arith_signature.push_back(type_utils::make_integer_type());
    global_env.set_predicate_signature("<", std::move(arith_signature));
    
    // More built-ins would be added here...
}

void TypeChecker::check_program(const ast::Program& program) {
    // First pass: collect type definitions
    for (const auto& type_def : program.type_definitions) {
        // Register custom types
    }
    
    // Second pass: collect predicate signatures from facts and rules
    for (const auto& clause : program.clauses) {
        if (auto fact = dynamic_cast<const ast::Fact*>(clause.get())) {
            // Infer predicate signature from fact
            std::vector<std::unique_ptr<ast::Type>> signature;
            
            for (const auto& arg : fact->head->arguments) {
                try {
                    auto type_result = infer_type(*arg);
                    if (type_result) {
                        signature.push_back(std::move(type_result.value()));
                    } else {
                        signature.push_back(type_utils::make_atom_type()); // Default
                    }
                } catch (...) {
                    signature.push_back(type_utils::make_atom_type()); // Default
                }
            }
            
            if (!global_env.has_predicate_signature(fact->head->functor)) {
                global_env.set_predicate_signature(fact->head->functor, std::move(signature));
            }
        }
    }
    
    // Third pass: type check all clauses
    auto env = global_env.create_child();
    
    for (const auto& clause : program.clauses) {
        if (auto fact = dynamic_cast<const ast::Fact*>(clause.get())) {
            check_fact(*fact, *env);
        } else if (auto rule = dynamic_cast<const ast::Rule*>(clause.get())) {
            check_rule(*rule, *env);
        } else if (auto query = dynamic_cast<const ast::Query*>(clause.get())) {
            check_query(*query, *env);
        }
    }
}

std::expected<std::unique_ptr<ast::Type>, TypeError> 
TypeChecker::infer_type(const ast::Term& term) {
    try {
        auto env = global_env.create_child();
        return infer_term_type(term, *env);
    } catch (const TypeError& e) {
        return std::unexpected(e);
    }
}

std::unique_ptr<ast::Type> TypeChecker::infer_term_type(const ast::Term& term, TypeEnvironment& env) {
    if (auto atom = dynamic_cast<const ast::Atom*>(&term)) {
        return infer_atom_type(*atom);
    } else if (auto variable = dynamic_cast<const ast::Variable*>(&term)) {
        return infer_variable_type(*variable, env);
    } else if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        return infer_compound_type(*compound, env);
    } else if (auto number = dynamic_cast<const ast::Number*>(&term)) {
        return infer_number_type(*number);
    } else if (auto string = dynamic_cast<const ast::String*>(&term)) {
        return infer_string_type(*string);
    }
    
    throw TypeError("Unknown term type", term.position);
}

std::unique_ptr<ast::Type> TypeChecker::infer_atom_type(const ast::Atom& atom) {
    return type_utils::make_atom_type();
}

std::unique_ptr<ast::Type> TypeChecker::infer_variable_type(const ast::Variable& var, TypeEnvironment& env) {
    if (env.has_variable_type(var.name)) {
        // Return copy of existing type
        return type_utils::make_atom_type(); // Simplified
    }
    
    // Create fresh type variable
    auto fresh_type = type_utils::make_compound_type("_T" + var.name);
    env.set_variable_type(var.name, type_utils::make_compound_type("_T" + var.name));
    
    return fresh_type;
}

std::unique_ptr<ast::Type> TypeChecker::infer_compound_type(const ast::Compound& compound, TypeEnvironment& env) {
    // Check if we have a signature for this predicate
    if (const auto* signature = env.get_predicate_signature(compound.functor)) {
        if (signature->size() != compound.arguments.size()) {
            throw TypeError(
                std::format("Arity mismatch for predicate {}: expected {}, got {}", 
                          compound.functor, signature->size(), compound.arguments.size()),
                compound.position);
        }
        
        // Type check arguments against signature
        for (size_t i = 0; i < compound.arguments.size(); ++i) {
            auto arg_type = infer_term_type(*compound.arguments[i], env);
            
            if (!types_compatible(*arg_type, *(*signature)[i])) {
                throw TypeError(
                    std::format("Type mismatch in argument {} of predicate {}", 
                              i + 1, compound.functor),
                    compound.arguments[i]->position);
            }
        }
        
        return type_utils::make_atom_type(); // Predicates have no return type in logic programming
    }
    
    // No signature found - infer from arguments
    return type_utils::make_atom_type();
}

std::unique_ptr<ast::Type> TypeChecker::infer_number_type(const ast::Number& number) {
    return type_utils::make_integer_type();
}

std::unique_ptr<ast::Type> TypeChecker::infer_string_type(const ast::String& string) {
    return type_utils::make_compound_type("string");
}

bool TypeChecker::types_compatible(const ast::Type& type1, const ast::Type& type2) const {
    // Simplified type compatibility check
    if (auto atom1 = dynamic_cast<const ast::AtomType*>(&type1)) {
        return dynamic_cast<const ast::AtomType*>(&type2) != nullptr;
    }
    
    if (auto int1 = dynamic_cast<const ast::IntegerType*>(&type1)) {
        return dynamic_cast<const ast::IntegerType*>(&type2) != nullptr;
    }
    
    if (auto comp1 = dynamic_cast<const ast::CompoundType*>(&type1)) {
        if (auto comp2 = dynamic_cast<const ast::CompoundType*>(&type2)) {
            return comp1->name == comp2->name && 
                   comp1->parameters.size() == comp2->parameters.size();
        }
    }
    
    return false;
}

void TypeChecker::check_fact(const ast::Fact& fact, TypeEnvironment& env) {
    // Type check the fact head
    infer_compound_type(*fact.head, env);
}

void TypeChecker::check_rule(const ast::Rule& rule, TypeEnvironment& env) {
    // Type check rule head
    infer_compound_type(*rule.head, env);
    
    // Type check rule body
    for (const auto& body_expr : rule.body) {
        check_expression(*body_expr, env);
    }
    
    // Type check conditions
    for (const auto& condition : rule.conditions) {
        check_expression(*condition, env);
    }
}

void TypeChecker::check_query(const ast::Query& query, TypeEnvironment& env) {
    // Type check query goals
    for (const auto& goal : query.goals) {
        check_expression(*goal, env);
    }
    
    // Type check conditions
    for (const auto& condition : query.conditions) {
        check_expression(*condition, env);
    }
}

void TypeChecker::check_expression(const ast::Expression& expr, TypeEnvironment& env) {
    if (auto call_expr = dynamic_cast<const ast::CallExpr*>(&expr)) {
        infer_compound_type(*call_expr->compound, env);
    }
    // Other expression types would be handled here...
}

// Pattern implementations
bool LiteralPattern::matches(const ast::Term& term, Substitution& bindings) const {
    UnificationEngine engine;
    auto result = engine.unify(*literal, term);
    
    if (result.success) {
        bindings = bindings.compose(result.substitution);
        return true;
    }
    return false;
}

std::unique_ptr<MatchPattern> LiteralPattern::clone() const {
    return std::make_unique<LiteralPattern>(term_utils::deep_copy(*literal));
}

bool VariablePattern::matches(const ast::Term& term, Substitution& bindings) const {
    // Variables always match, bind the variable to the term
    bindings.bind(variable_name, term_utils::deep_copy(term));
    return true;
}

std::unique_ptr<MatchPattern> VariablePattern::clone() const {
    return std::make_unique<VariablePattern>(variable_name);
}

bool CompoundPattern::matches(const ast::Term& term, Substitution& bindings) const {
    if (auto compound = dynamic_cast<const ast::Compound*>(&term)) {
        if (compound->functor != functor || 
            compound->arguments.size() != argument_patterns.size()) {
            return false;
        }
        
        // Match all argument patterns
        for (size_t i = 0; i < argument_patterns.size(); ++i) {
            if (!argument_patterns[i]->matches(*compound->arguments[i], bindings)) {
                return false;
            }
        }
        
        return true;
    }
    return false;
}

std::unique_ptr<MatchPattern> CompoundPattern::clone() const {
    auto cloned = std::make_unique<CompoundPattern>(functor);
    
    for (const auto& pattern : argument_patterns) {
        cloned->argument_patterns.push_back(pattern->clone());
    }
    
    return std::move(cloned);
}

bool WildcardPattern::matches(const ast::Term& term, Substitution& bindings) const {
    return true; // Wildcard matches everything
}

std::unique_ptr<MatchPattern> WildcardPattern::clone() const {
    return std::make_unique<WildcardPattern>();
}

// PatternMatcher implementation
PatternMatcher::MatchResult PatternMatcher::match(const ast::Term& term, const MatchPattern& pattern) const {
    Substitution bindings;
    
    if (pattern.matches(term, bindings)) {
        return MatchResult::success(std::move(bindings));
    }
    
    return MatchResult::failure();
}

PatternMatcher::MatchResult PatternMatcher::match_all(
    const std::vector<std::reference_wrapper<const ast::Term>>& terms,
    const std::vector<std::reference_wrapper<const MatchPattern>>& patterns) const {
    
    if (terms.size() != patterns.size()) {
        return MatchResult::failure();
    }
    
    Substitution combined_bindings;
    
    for (size_t i = 0; i < terms.size(); ++i) {
        auto result = match(terms[i].get(), patterns[i].get());
        if (!result.success) {
            return MatchResult::failure();
        }
        
        combined_bindings = combined_bindings.compose(result.bindings);
    }
    
    return MatchResult::success(std::move(combined_bindings));
}

// Type utilities
namespace type_utils {

std::string type_to_string(const ast::Type& type) {
    if (dynamic_cast<const ast::AtomType*>(&type)) {
        return "atom";
    } else if (dynamic_cast<const ast::IntegerType*>(&type)) {
        return "i32";
    } else if (auto compound_type = dynamic_cast<const ast::CompoundType*>(&type)) {
        if (compound_type->parameters.empty()) {
            return compound_type->name;
        } else {
            std::string result = compound_type->name + "<";
            for (size_t i = 0; i < compound_type->parameters.size(); ++i) {
                if (i > 0) result += ", ";
                result += type_to_string(*compound_type->parameters[i]);
            }
            result += ">";
            return result;
        }
    }
    
    return "unknown";
}

bool is_ground_type(const ast::Type& type) {
    if (auto compound_type = dynamic_cast<const ast::CompoundType*>(&type)) {
        // Type variables start with underscore
        if (compound_type->name.starts_with("_T")) {
            return false;
        }
        
        // Check if all parameters are ground
        for (const auto& param : compound_type->parameters) {
            if (!is_ground_type(*param)) {
                return false;
            }
        }
    }
    
    return true;
}

size_t get_type_arity(const ast::Type& type) {
    if (auto compound_type = dynamic_cast<const ast::CompoundType*>(&type)) {
        return compound_type->parameters.size();
    }
    return 0;
}

std::unique_ptr<ast::Type> make_atom_type() {
    return std::make_unique<ast::AtomType>(Position{});
}

std::unique_ptr<ast::Type> make_integer_type() {
    return std::make_unique<ast::IntegerType>(Position{});
}

std::unique_ptr<ast::Type> make_compound_type(const std::string& name) {
    return std::make_unique<ast::CompoundType>(Position{}, name);
}

} // namespace type_utils

} // namespace logicpp#pragma once

#include "ast.hpp"
#include <unordered_map>
#include <string>
#include <memory>
#include <optional>
#include <vector>
#include <functional>

namespace logicpp {

// Substitution maps variable names to terms
class Substitution {
private:
    std::unordered_map<std::string, std::unique_ptr<ast::Term>> bindings;

public:
    Substitution() = default;
    Substitution(const Substitution& other);
    Substitution& operator=(const Substitution& other);
    Substitution(Substitution&&) = default;
    Substitution& operator=(Substitution&&) = default;

    // Add a binding from variable to term
    void bind(const std::string& variable, std::unique_ptr<ast::Term> term);
    
    // Get the binding for a variable
    const ast::Term* lookup(const std::string& variable) const;
    
    // Check if a variable is bound
    bool is_bound(const std::string& variable) const;
    
    // Apply substitution to a term
    std::unique_ptr<ast::Term> apply(const ast::Term& term) const;
    
    // Compose two substitutions
    Substitution compose(const Substitution& other) const;
    
    // Get all variable names
    std::vector<std::string> variables() const;
    
    // Check if substitution is empty
    bool empty() const { return bindings.empty(); }
    
    // Clear all bindings
    void clear() { bindings.clear(); }
    
    // Debug: print substitution
    std::string to_string() const;
};

// Unification result
struct UnificationResult {
    bool success;
    Substitution substitution;
    
    UnificationResult(bool s) : success(s) {}
    UnificationResult(bool s, Substitution sub) 
        : success(s), substitution(std::move(sub)) {}
    
    static UnificationResult failure() { return UnificationResult(false); }
    static UnificationResult success(Substitution sub = {}) { 
        return UnificationResult(true, std::move(sub)); 
    }
};

// Main unification engine
class UnificationEngine {
private:
    // Helper methods for different term types
    UnificationResult unify_variables(
        const ast::Variable& var1, 
        const ast::Variable& var2,
        Substitution& substitution) const;
    
    UnificationResult unify_variable_with_term(
        const ast::Variable& variable,
        const ast::Term& term,
        Substitution& substitution) const;
    
    UnificationResult unify_compounds(
        const ast::Compound& comp1,
        const ast::Compound& comp2,
        Substitution& substitution) const;
    
    UnificationResult unify_atoms(
        const ast::Atom& atom1,
        const ast::Atom& atom2) const;
    
    UnificationResult unify_numbers(
        const ast::Number& num1,
        const ast::Number& num2) const;
    
    UnificationResult unify_strings(
        const ast::String& str1,
        const ast::String& str2) const;
    
    // Occur check: prevents infinite structures
    bool occurs_check(const std::string& variable, const ast::Term& term) const;
    
    // Deep clone a term
    std::unique_ptr<ast::Term> clone_term(const ast::Term& term) const;

public:
    // Main unification method
    UnificationResult unify(const ast::Term& term1, const ast::Term& term2) const;
    
    // Unify with existing substitution
    UnificationResult unify(
        const ast::Term& term1, 
        const ast::Term& term2,
        const Substitution& existing_substitution) const;
    
    // Unify lists of terms (for compound arguments)
    UnificationResult unify_lists(
        const std::vector<std::unique_ptr<ast::Term>>& terms1,
        const std::vector<std::unique_ptr<ast::Term>>& terms2,
        Substitution& substitution) const;
    
    // Check if two terms are unifiable without computing substitution
    bool unifiable(const ast::Term& term1, const ast::Term& term2) const;
    
    // Rename variables in a term to avoid conflicts
    std::unique_ptr<ast::Term> rename_variables(
        const ast::Term& term, 
        const std::string& prefix = "V") const;
    
    // Generate fresh variable name
    std::string fresh_variable_name(const std::string& base = "X") const;
};

// Utility functions for term manipulation
namespace term_utils {
    
    // Check if term is a variable
    bool is_variable(const ast::Term& term);
    
    // Check if term is ground (contains no variables)
    bool is_ground(const ast::Term& term);
    
    // Get all variables in a term
    std::vector<std::string> get_variables(const ast::Term& term);
    
    // Compare terms for structural equality
    bool structurally_equal(const ast::Term& term1, const ast::Term& term2);
    
    // Convert term to string representation
    std::string term_to_string(const ast::Term& term);
    
    // Deep copy a term
    std::unique_ptr<ast::Term> deep_copy(const ast::Term& term);
    
} // namespace term_utils

} // namespace logicpp#include "lexer.hpp"
#include <cctype>
#include <iostream>

namespace logicpp {

const std::unordered_map<std::string, TokenType> Lexer::keywords = {
    {"fact", TokenType::FACT},
    {"rule", TokenType::RULE},
    {"type", TokenType::TYPE},
    {"fn", TokenType::FN},
    {"match", TokenType::MATCH},
    {"where", TokenType::WHERE},
    {"let", TokenType::LET}
};

char Lexer::peek(size_t offset) const noexcept {
    const size_t pos = current_pos + offset;
    return (pos < source.length()) ? source[pos] : '\0';
}

char Lexer::advance() noexcept {
    if (at_end()) return '\0';
    
    const char ch = source[current_pos++];
    if (ch == '\n') {
        position.line++;
        position.column = 1;
    } else {
        position.column++;
    }
    position.offset++;
    return ch;
}

void Lexer::skip_whitespace() noexcept {
    while (!at_end()) {
        const char ch = peek();
        if (ch == ' ' || ch == '\t' || ch == '\r') {
            advance();
        } else if (ch == '/' && peek(1) == '/') {
            skip_comment();
        } else {
            break;
        }
    }
}

void Lexer::skip_comment() noexcept {
    // Skip until end of line
    while (!at_end() && peek() != '\n') {
        advance();
    }
}

Token Lexer::make_token(TokenType type, std::string value) const {
    return Token(type, std::move(value), position);
}

Token Lexer::scan_identifier() {
    const size_t start_pos = current_pos - 1; // We already consumed first char
    
    while (!at_end()) {
        const char ch = peek();
        if (std::isalnum(ch) || ch == '_') {
            advance();
        } else {
            break;
        }
    }
    
    std::string value(source.substr(start_pos, current_pos - start_pos));
    
    // Check if it's a keyword
    if (auto it = keywords.find(value); it != keywords.end()) {
        return make_token(it->second, std::move(value));
    }
    
    return make_token(TokenType::IDENTIFIER, std::move(value));
}

Token Lexer::scan_number() {
    const size_t start_pos = current_pos - 1;
    bool is_float = false;
    
    while (!at_end() && std::isdigit(peek())) {
        advance();
    }
    
    // Check for decimal point
    if (!at_end() && peek() == '.' && std::isdigit(peek(1))) {
        is_float = true;
        advance(); // consume '.'
        while (!at_end() && std::isdigit(peek())) {
            advance();
        }
    }
    
    std::string value(source.substr(start_pos, current_pos - start_pos));
    TokenType type = is_float ? TokenType::FLOAT : TokenType::INTEGER;
    
    return make_token(type, std::move(value));
}

Token Lexer::scan_string() {
    const size_t start_pos = current_pos;
    
    while (!at_end()) {
        const char ch = peek();
        if (ch == '"') {
            break;
        } else if (ch == '\\') {
            advance(); // Skip escape character
            if (!at_end()) advance(); // Skip escaped character
        } else {
            advance();
        }
    }
    
    if (at_end()) {
        return make_token(TokenType::INVALID, "Unterminated string");
    }
    
    std::string value(source.substr(start_pos, current_pos - start_pos));
    advance(); // Consume closing quote
    
    return make_token(TokenType::STRING, std::move(value));
}

Token Lexer::scan_operator() {
    const char ch1 = peek(-1); // We already advanced
    const char ch2 = peek();
    
    // Two-character operators
    if (ch2 != '\0') {
        std::string two_char = std::string(1, ch1) + ch2;
        
        if (two_char == ":-") {
            advance();
            return make_token(TokenType::RULE_OP, ":-");
        } else if (two_char == "?-") {
            advance();
            return make_token(TokenType::QUERY_OP, "?-");
        } else if (two_char == "->") {
            advance();
            return make_token(TokenType::ARROW, "->");
        } else if (two_char == "\\=") {
            advance();
            return make_token(TokenType::NOT_UNIFY, "\\=");
        } else if (two_char == "<=") {
            advance();
            return make_token(TokenType::LESS_EQUAL, "<=");
        } else if (two_char == ">=") {
            advance();
            return make_token(TokenType::GREATER_EQUAL, ">=");
        } else if (two_char == "==") {
            advance();
            return make_token(TokenType::EQUAL, "==");
        } else if (two_char == "!=") {
            advance();
            return make_token(TokenType::NOT_EQUAL, "!=");
        }
    }
    
    // Single-character operators and delimiters
    switch (ch1) {
        case '=': return make_token(TokenType::UNIFY, "=");
        case '<': return make_token(TokenType::LESS, "<");
        case '>': return make_token(TokenType::GREATER, ">");
        case '|': return make_token(TokenType::PIPE, "|");
        case '(': return make_token(TokenType::LPAREN, "(");
        case ')': return make_token(TokenType::RPAREN, ")");
        case '{': return make_token(TokenType::LBRACE, "{");
        case '}': return make_token(TokenType::RBRACE, "}");
        case '[': return make_token(TokenType::LBRACKET, "[");
        case ']': return make_token(TokenType::RBRACKET, "]");
        case '.': return make_token(TokenType::DOT, ".");
        case ',': return make_token(TokenType::COMMA, ",");
        case ';': return make_token(TokenType::SEMICOLON, ";");
        case ':': return make_token(TokenType::COLON, ":");
        case '_': return make_token(TokenType::UNDERSCORE, "_");
        default:
            return make_token(TokenType::INVALID, 
                            std::format("Unexpected character: '{}'", ch1));
    }
}

Token Lexer::next_token() {
    skip_whitespace();
    
    if (at_end()) {
        return make_token(TokenType::EOF_TOKEN, "");
    }
    
    const char ch = advance();
    
    if (ch == '\n') {
        return make_token(TokenType::NEWLINE, "\n");
    }
    
    if (std::isalpha(ch) || ch == '_') {
        return scan_identifier();
    }
    
    if (std::isdigit(ch)) {
        return scan_number();
    }
    
    if (ch == '"') {
        return scan_string();
    }
    
    return scan_operator();
}

std::vector<Token> Lexer::tokenize() {
    std::vector<Token> tokens;
    
    while (true) {
        Token token = next_token();
        const bool is_eof = (token.type == TokenType::EOF_TOKEN);
        
        tokens.push_back(std::move(token));
        
        if (is_eof) break;
    }
    
    return tokens;
}

std::string to_string(TokenType type) {
    switch (type) {
        case TokenType::IDENTIFIER: return "IDENTIFIER";
        case TokenType::INTEGER: return "INTEGER";
        case TokenType::FLOAT: return "FLOAT";
        case TokenType::STRING: return "STRING";
        case TokenType::ATOM: return "ATOM";
        case TokenType::FACT: return "FACT";
        case TokenType::RULE: return "RULE";
        case TokenType::QUERY: return "QUERY";
        case TokenType::TYPE: return "TYPE";
        case TokenType::FN: return "FN";
        case TokenType::MATCH: return "MATCH";
        case TokenType::WHERE: return "WHERE";
        case TokenType::LET: return "LET";
        case TokenType::RULE_OP: return "RULE_OP";
        case TokenType::QUERY_OP: return "QUERY_OP";
        case TokenType::ARROW: return "ARROW";
        case TokenType::PIPE: return "PIPE";
        case TokenType::UNIFY: return "UNIFY";
        case TokenType::NOT_UNIFY: return "NOT_UNIFY";
        case TokenType::LESS: return "LESS";
        case TokenType::GREATER: return "GREATER";
        case TokenType::LESS_EQUAL: return "LESS_EQUAL";
        case TokenType::GREATER_EQUAL: return "GREATER_EQUAL";
        case TokenType::EQUAL: return "EQUAL";
        case TokenType::NOT_EQUAL: return "NOT_EQUAL";
        case TokenType::LPAREN: return "LPAREN";
        case TokenType::RPAREN: return "RPAREN";
        case TokenType::LBRACE: return "LBRACE";
        case TokenType::RBRACE: return "RBRACE";
        case TokenType::LBRACKET: return "LBRACKET";
        case TokenType::RBRACKET: return "RBRACKET";
        case TokenType::DOT: return "DOT";
        case TokenType::COMMA: return "COMMA";
        case TokenType::SEMICOLON: return "SEMICOLON";
        case TokenType::COLON: return "COLON";
        case TokenType::UNDERSCORE: return "UNDERSCORE";
        case TokenType::NEWLINE: return "NEWLINE";
        case TokenType::EOF_TOKEN: return "EOF";
        case TokenType::INVALID: return "INVALID";
        default: return "UNKNOWN";
    }
}

std::ostream& operator<<(std::ostream& os, const Token& token) {
    return os << std::format("{}({}) at {}:{}", 
                           to_string(token.type), 
                           token.value,
                           token.position.line,
                           token.position.column);
}

} // namespace logicpp#include "resolver.hpp"
#include "parser.hpp"
#include <format>
#include <iostream>
#include <algorithm>
#include <atomic>

namespace logicpp {

// KnowledgeBase implementation
void KnowledgeBase::add_fact(std::unique_ptr<ast::Fact> fact) {
    facts.push_back(std::move(fact));
}

void KnowledgeBase::add_rule(std::unique_ptr<ast::Rule> rule) {
    rules.push_back(std::move(rule));
}

std::vector<const ast::Clause*> KnowledgeBase::get_matching_clauses(const ast::Compound& goal) const {
    std::vector<const ast::Clause*> matching;
    
    // Check facts
    for (const auto& fact : facts) {
        if (fact->head->functor == goal.functor && 
            fact->head->arguments.size() == goal.arguments.size()) {
            matching.push_back(fact.get());
        }
    }
    
    // Check rules
    for (const auto& rule : rules) {
        if (rule->head->functor == goal.functor && 
            rule->head->arguments.size() == goal.arguments.size()) {
            matching.push_back(rule.get());
        }
    }
    
    return matching;
}

void KnowledgeBase::clear() {
    facts.clear();
    rules.clear();
}

void KnowledgeBase::print_knowledge() const {
    std::cout << "Facts:\n";
    for (const auto& fact : facts) {
        std::cout << "  " << term_utils::term_to_string(*fact->head) << ".\n";
    }
    
    std::cout << "Rules:\n";
    for (const auto& rule : rules) {
        std::cout << "  " << term_utils::term_to_string(*rule->head) << " :- ";
        for (size_t i = 0; i < rule->body.size(); ++i) {
            if (i > 0) std::cout << ", ";
            // Simplified - would need proper expression printing
            std::cout << "<?>";
        }
        std::cout << ".\n";
    }
}

// Solution implementation
bool Solution::binds(const std::string& variable) const {
    return bindings.is_bound(variable);
}

std::string Solution::get_binding_string(const std::string& variable) const {
    if (const ast::Term* term = bindings.lookup(variable)) {
        return term_utils::term_to_string(*term);
    }
    return variable;  // Unbound variable
}

std::string Solution::to_string() const {
    if (bindings.empty()) {
        return "true";
    }
    
    std::string result = "{ ";
    bool first = true;
    
    for (const std::string& var : variable_names) {
        if (bindings.is_bound(var)) {
            if (!first) result += ", ";
            result += var + " = " + get_binding_string(var);
            first = false;
        }
    }
    
    result += " }";
    return result;
}

// QueryResolver implementation
void QueryResolver::trace(const std::string& message, size_t depth) const {
    if (options.trace_execution) {
        for (size_t i = 0; i < depth; ++i) {
            std::cout << "  ";
        }
        std::cout << message << std::endl;
    }
}

std::vector<Solution> QueryResolver::resolve_query(const ast::Query& query) const {
    std::vector<Solution> solutions;
    
    if (query.goals.empty()) {
        return solutions;
    }
    
    // Extract variable names from query
    std::set<std::string> query_vars;
    for (const auto& goal : query.goals) {
        // Simplified - would need proper variable extraction from expressions
        if (auto call_expr = dynamic_cast<const ast::CallExpr*>(goal.get())) {
            auto vars = term_utils::get_variables(*call_expr->compound);
            query_vars.insert(vars.begin(), vars.end());
        }
    }
    
    std::vector<std::string> var_names(query_vars.begin(), query_vars.end());
    
    // Convert first goal to compound and start resolution
    if (auto call_expr = dynamic_cast<const ast::CallExpr*>(query.goals[0].get())) {
        auto compound_copy = std::unique_ptr<ast::Compound>(
            dynamic_cast<ast::Compound*>(term_utils::deep_copy(*call_expr->compound).release()));
        
        Goal initial_goal(std::move(compound_copy));
        
        std::vector<Goal> remaining_goals;
        
        // Add remaining goals from query
        for (size_t i = 1; i < query.goals.size(); ++i) {
            if (auto call_expr_i = dynamic_cast<const ast::CallExpr*>(query.goals[i].get())) {
                auto compound_i = std::unique_ptr<ast::Compound>(
                    dynamic_cast<ast::Compound*>(term_utils::deep_copy(*call_expr_i->compound).release()));
                remaining_goals.emplace_back(std::move(compound_i));
            }
        }
        
        resolve_goal(initial_goal, remaining_goals, solutions);
        
        // Set variable names in solutions
        for (auto& solution : solutions) {
            solution.variable_names = var_names;
        }
    }
    
    return solutions;
}

std::vector<Solution> QueryResolver::resolve_goal(const ast::Compound& goal) const {
    auto compound_copy = std::unique_ptr<ast::Compound>(
        dynamic_cast<ast::Compound*>(term_utils::deep_copy(goal).release()));
    
    Goal goal_obj(std::move(compound_copy));
    std::vector<Goal> remaining_goals;
    std::vector<Solution> solutions;
    
    resolve_goal(goal_obj, remaining_goals, solutions);
    
    // Extract variable names from goal
    auto var_names = term_utils::get_variables(goal);
    for (auto& solution : solutions) {
        solution.variable_names = var_names;
    }
    
    return solutions;
}

void QueryResolver::resolve_goal(
    const Goal& goal,
    std::vector<Goal>& remaining_goals,
    std::vector<Solution>& solutions) const {
    
    if (depth_limit_exceeded(goal.depth)) {
        trace(std::format("Depth limit exceeded for goal: {}", 
              term_utils::term_to_string(*goal.compound)), goal.depth);
        return;
    }
    
    trace(std::format("Resolving goal: {} at depth {}", 
          term_utils::term_to_string(*goal.compound), goal.depth), goal.depth);
    
    // Apply current substitution to the goal
    auto applied_goal = std::unique_ptr<ast::Compound>(
        dynamic_cast<ast::Compound*>(goal.substitution.apply(*goal.compound).release()));
    
    // Get matching clauses
    auto matching_clauses = knowledge_base.get_matching_clauses(*applied_goal);
    
    for (const ast::Clause* clause : matching_clauses) {
        // Rename variables in clause to avoid conflicts
        auto renamed_clause = rename_clause_variables(*clause, generate_variable_prefix());
        
        if (auto fact = dynamic_cast<const ast::Fact*>(renamed_clause.get())) {
            // Try to unify with fact
            auto unify_result = unification_engine.unify(*applied_goal, *fact->head);
            
            if (unify_result.success) {
                trace(std::format("Unified with fact: {}", 
                      term_utils::term_to_string(*fact->head)), goal.depth);
                
                // Compose substitutions
                Substitution combined_substitution = goal.substitution.compose(unify_result.substitution);
                
                if (remaining_goals.empty()) {
                    // Found a solution
                    Solution solution;
                    solution.bindings = std::move(combined_substitution);
                    solutions.push_back(std::move(solution));
                    
                    if (!options.find_all_solutions) {
                        return;  // Stop at first solution
                    }
                } else {
                    // Apply substitution to remaining goals and continue
                    auto updated_goals = apply_substitution_to_goals(remaining_goals, combined_substitution);
                    
                    Goal next_goal = std::move(updated_goals[0]);
                    next_goal.depth = goal.depth + 1;
                    
                    std::vector<Goal> rest_goals(updated_goals.begin() + 1, updated_goals.end());
                    resolve_goal(next_goal, rest_goals, solutions);
                }
            }
        } else if (auto rule = dynamic_cast<const ast::Rule*>(renamed_clause.get())) {
            // Try to unify with rule head
            auto unify_result = unification_engine.unify(*applied_goal, *rule->head);
            
            if (unify_result.success) {
                trace(std::format("Unified with rule head: {}", 
                      term_utils::term_to_string(*rule->head)), goal.depth);
                
                // Compose substitutions
                Substitution combined_substitution = goal.substitution.compose(unify_result.substitution);
                
                // Add rule body goals to remaining goals
                std::vector<Goal> new_goals;
                
                // Convert rule body expressions to goals (simplified)
                for (const auto& body_expr : rule->body) {
                    if (auto call_expr = dynamic_cast<const ast::CallExpr*>(body_expr.get())) {
                        auto compound_copy = std::unique_ptr<ast::Compound>(
                            dynamic_cast<ast::Compound*>(term_utils::deep_copy(*call_expr->compound).release()));
                        new_goals.emplace_back(std::move(compound_copy), combined_substitution, goal.depth + 1);
                    }
                }
                
                // Add original remaining goals
                new_goals.insert(new_goals.end(), remaining_goals.begin(), remaining_goals.end());
                
                if (!new_goals.empty()) {
                    Goal next_goal = std::move(new_goals[0]);
                    std::vector<Goal> rest_goals(new_goals.begin() + 1, new_goals.end());
                    resolve_goal(next_goal, rest_goals, solutions);
                } else if (remaining_goals.empty()) {
                    // Rule with empty body - found solution
                    Solution solution;
                    solution.bindings = std::move(combined_substitution);
                    solutions.push_back(std::move(solution));
                }
            }
        }
        
        // Check if we've found enough solutions
        if (solutions.size() >= options.max_solutions) {
            break;
        }
    }
}

std::vector<Goal> QueryResolver::apply_substitution_to_goals(
    const std::vector<Goal>& goals,
    const Substitution& substitution) const {
    
    std::vector<Goal> updated_goals;
    updated_goals.reserve(goals.size());
    
    for (const auto& goal : goals) {
        auto applied_compound = std::unique_ptr<ast::Compound>(
            dynamic_cast<ast::Compound*>(substitution.apply(*goal.compound).release()));
        
        Substitution combined_sub = goal.substitution.compose(substitution);
        updated_goals.emplace_back(std::move(applied_compound), std::move(combined_sub), goal.depth);
    }
    
    return updated_goals;
}

bool QueryResolver::depth_limit_exceeded(size_t depth) const {
    return depth >= options.max_depth;
}

std::unique_ptr<ast::Clause> QueryResolver::rename_clause_variables(
    const ast::Clause& clause,
    const std::string& prefix) const {
    
    // Simplified implementation - in practice would need full variable renaming
    if (auto fact = dynamic_cast<const ast::Fact*>(&clause)) {
        auto renamed_compound = std::unique_ptr<ast::Compound>(
            dynamic_cast<ast::Compound*>(term_utils::deep_copy(*fact->head).release()));
        
        return std::make_unique<ast::Fact>(fact->position, std::move(renamed_compound));
    } else if (auto rule = dynamic_cast<const ast::Rule*>(&clause)) {
        auto renamed_head = std::unique_ptr<ast::Compound>(
            dynamic_cast<ast::Compound*>(term_utils::deep_copy(*rule->head).release()));
        
        auto renamed_rule = std::make_unique<ast::Rule>(rule->position, std::move(renamed_head));
        
        // Copy body (simplified - would need proper renaming)
        for (const auto& body_expr : rule->body) {
            // Simplified copy
        }
        
        return std::move(renamed_rule);
    }
    
    return nullptr;
}

std::string QueryResolver::generate_variable_prefix() const {
    static std::atomic<size_t> counter{0};
    return std::format("_G{}_", counter.fetch_add(1));
}

bool QueryResolver::can_prove(const ast::Compound& goal) const {
    auto solutions = resolve_goal(goal);
    return !solutions.empty();
}

std::optional<Solution> QueryResolver::get_first_solution(const ast::Compound& goal) const {
    ResolverOptions temp_options = options;
    temp_options.find_all_solutions = false;
    temp_options.max_solutions = 1;
    
    QueryResolver temp_resolver(knowledge_base, temp_options);
    auto solutions = temp_resolver.resolve_goal(goal);
    
    if (!solutions.empty()) {
        return solutions[0];
    }
    return std::nullopt;
}

// QueryEngine implementation
void QueryEngine::load_program(const ast::Program& program) {
    for (const auto& clause : program.clauses) {
        if (auto fact = dynamic_cast<const ast::Fact*>(clause.get())) {
            auto fact_copy = std::unique_ptr<ast::Fact>(
                dynamic_cast<ast::Fact*>(term_utils::deep_copy(*fact).release()));
            knowledge_base.add_fact(std::move(fact_copy));
        } else if (auto rule = dynamic_cast<const ast::Rule*>(clause.get())) {
            auto rule_copy = std::unique_ptr<ast::Rule>(
                dynamic_cast<ast::Rule*>(term_utils::deep_copy(*rule).release()));
            knowledge_base.add_rule(std::move(rule_copy));
        }
    }
}

void QueryEngine::add_fact(std::unique_ptr<ast::Fact> fact) {
    knowledge_base.add_fact(std::move(fact));
}

void QueryEngine::add_rule(std::unique_ptr<ast::Rule> rule) {
    knowledge_base.add_rule(std::move(rule));
}

std::vector<Solution> QueryEngine::query(const std::string& query_string) {
    auto parse_result = Parser::parse_source(query_string);
    if (!parse_result) {
        return {};  // Parse error
    }
    
    auto& program = *parse_result.value();
    if (!program.clauses.empty()) {
        if (auto query = dynamic_cast<const ast::Query*>(program.clauses[0].get())) {
            return resolver.resolve_query(*query);
        }
    }
    
    return {};
}

std::vector<Solution> QueryEngine::query(const ast::Query& query) {
    return resolver.resolve_query(query);
}

bool QueryEngine::ask(const std::string& goal_string) {
    // Parse as simple compound term query
    auto parse_result = Parser::parse_source("?- " + goal_string + ".");
    if (!parse_result) {
        return false;
    }
    
    auto& program = *parse_result.value();
    if (!program.clauses.empty()) {
        if (auto query = dynamic_cast<const ast::Query*>(program.clauses[0].get())) {
            auto solutions = resolver.resolve_query(*query);
            return !solutions.empty();
        }
    }
    
    return false;
}

bool QueryEngine::ask(const ast::Compound& goal) {
    return resolver.can_prove(goal);
}

QueryEngine::Stats QueryEngine::get_stats() const {
    return {knowledge_base.fact_count(), knowledge_base.rule_count()};
}

// Solution utilities
namespace solution_utils {

void print_solutions(const std::vector<Solution>& solutions) {
    if (solutions.empty()) {
        std::cout << "false.\n";
        return;
    }
    
    for (size_t i = 0; i < solutions.size(); ++i) {
        std::cout << "Solution " << (i + 1) << ": " << solutions[i].to_string() << std::endl;
    }
}

bool solutions_contain_binding(
    const std::vector<Solution>& solutions,
    const std::string& variable,
    const std::string& value) {
    
    return std::any_of(solutions.begin(), solutions.end(),
        [&](const Solution& sol) {
            return sol.binds(variable) && sol.get_binding_string(variable) == value;
        });
}

std::vector<Solution> filter_solutions_by_binding(
    const std::vector<Solution>& solutions,
    const std::string& variable,
    const std::function<bool(const std::string&)>& predicate) {
    
    std::vector<Solution> filtered;
    
    for (const auto& solution : solutions) {
        if (solution.binds(variable) && 
            predicate(solution.get_binding_string(variable))) {
            filtered.push_back(solution);
        }
    }
    
    return filtered;
}

} // namespace solution_utils

} // namespace logicpp#pragma once

#include "ast.hpp"
#include <unordered_map>
#include <string>
#include <vector>
#include <memory>
#include <expected>

namespace logicpp {

// Type checking errors
class TypeError : public std::exception {
private:
    std::string message;
    Position position;

public:
    TypeError(std::string msg, Position pos) 
        : message(std::move(msg)), position(pos) {}
    
    const char* what() const noexcept override { return message.c_str(); }
    Position where() const noexcept { return position; }
};

// Type environment for variable and predicate types
class TypeEnvironment {
private:
    std::unordered_map<std::string, std::unique_ptr<ast::Type>> variable_types;
    std::unordered_map<std::string, std::vector<std::unique_ptr<ast::Type>>> predicate_types;
    
public:
    // Variable types
    void set_variable_type(const std::string& var, std::unique_ptr<ast::Type> type);
    const ast::Type* get_variable_type(const std::string& var) const;
    bool has_variable_type(const std::string& var) const;
    
    // Predicate types (signature)
    void set_predicate_signature(const std::string& predicate, 
                                std::vector<std::unique_ptr<ast::Type>> signature);
    const std::vector<std::unique_ptr<ast::Type>>* get_predicate_signature(const std::string& predicate) const;
    bool has_predicate_signature(const std::string& predicate) const;
    
    // Create child environment (for scoping)
    std::unique_ptr<TypeEnvironment> create_child() const;
    
    // Merge with another environment
    void merge(const TypeEnvironment& other);
};

// Type inference and checking
class TypeChecker {
private:
    TypeEnvironment global_env;
    
    // Helper methods
    std::unique_ptr<ast::Type> infer_term_type(const ast::Term& term, TypeEnvironment& env);
    std::unique_ptr<ast::Type> infer_atom_type(const ast::Atom& atom);
    std::unique_ptr<ast::Type> infer_variable_type(const ast::Variable& var, TypeEnvironment& env);
    std::unique_ptr<ast::Type> infer_compound_type(const ast::Compound& compound, TypeEnvironment& env);
    std::unique_ptr<ast::Type> infer_number_type(const ast::Number& number);
    std::unique_ptr<ast::Type> infer_string_type(const ast::String& string);
    
    // Type compatibility
    bool types_compatible(const ast::Type& type1, const ast::Type& type2) const;
    std::unique_ptr<ast::Type> unify_types(const ast::Type& type1, const ast::Type& type2);
    
    // Type checking for clauses
    void check_fact(const ast::Fact& fact, TypeEnvironment& env);
    void check_rule(const ast::Rule& rule, TypeEnvironment& env);
    void check_query(const ast::Query& query, TypeEnvironment& env);
    
    // Expression type checking
    void check_expression(const ast::Expression& expr, TypeEnvironment& env);
    
public:
    TypeChecker();
    
    // Main type checking methods
    void check_program(const ast::Program& program);
    void add_builtin_types();
    
    // Type inference
    std::expected<std::unique_ptr<ast::Type>, TypeError> infer_type(const ast::Term& term);
    
    // Manual type annotations
    void add_predicate_type(const std::string& predicate, 
                           std::vector<std::unique_ptr<ast::Type>> signature);
    
    // Get type environment
    const TypeEnvironment& get_global_environment() const { return global_env; }
};

// Pattern matching implementation
struct MatchPattern {
    virtual ~MatchPattern() = default;
    virtual bool matches(const ast::Term& term, Substitution& bindings) const = 0;
    virtual std::unique_ptr<MatchPattern> clone() const = 0;
};

struct LiteralPattern : MatchPattern {
    std::unique_ptr<ast::Term> literal;
    
    LiteralPattern(std::unique_ptr<ast::Term> lit) : literal(std::move(lit)) {}
    
    bool matches(const ast::Term& term, Substitution& bindings) const override;
    std::unique_ptr<MatchPattern> clone() const override;
};

struct VariablePattern : MatchPattern {
    std::string variable_name;
    
    VariablePattern(std::string name) : variable_name(std::move(name)) {}
    
    bool matches(const ast::Term& term, Substitution& bindings) const override;
    std::unique_ptr<MatchPattern> clone() const override;
};

struct CompoundPattern : MatchPattern {
    std::string functor;
    std::vector<std::unique_ptr<MatchPattern>> argument_patterns;
    
    CompoundPattern(std::string f) : functor(std::move(f)) {}
    
    bool matches(const ast::Term& term, Substitution& bindings) const override;
    std::unique_ptr<MatchPattern> clone() const override;
};

struct WildcardPattern : MatchPattern {
    bool matches(const ast::Term& term, Substitution& bindings) const override;
    std::unique_ptr<MatchPattern> clone() const override;
};

// Pattern matching engine
class PatternMatcher {
public:
    struct MatchResult {
        bool success;
        Substitution bindings;
        
        MatchResult(bool s) : success(s) {}
        MatchResult(bool s, Substitution b) : success(s), bindings(std::move(b)) {}
        
        static MatchResult success(Substitution bindings = {}) {
            return MatchResult(true, std::move(bindings));
        }
        
        static MatchResult failure() {
            return MatchResult(false);
        }
    };
    
    // Match a term against a pattern
    MatchResult match(const ast::Term& term, const MatchPattern& pattern) const;
    
    // Match multiple terms against patterns
    MatchResult match_all(
        const std::vector<std::reference_wrapper<const ast::Term>>& terms,
        const std::vector<std::reference_wrapper<const MatchPattern>>& patterns) const;
};

// Enhanced resolver with pattern matching and type checking
class TypedResolver {
private:
    TypeChecker type_checker;
    PatternMatcher pattern_matcher;
    
public:
    TypedResolver();
    
    // Type-safe query resolution
    // (extends basic resolver with type checking)
    
    // Pattern-based goal matching
    // (uses pattern matching for more sophisticated goal resolution)
};

// Type utilities
namespace type_utils {
    
    // Convert type to string representation
    std::string type_to_string(const ast::Type& type);
    
    // Check if type is ground (fully specified)
    bool is_ground_type(const ast::Type& type);
    
    // Get type arity (for compound types)
    size_t get_type_arity(const ast::Type& type);
    
    // Create basic types
    std::unique_ptr<ast::Type> make_atom_type();
    std::unique_ptr<ast::Type> make_integer_type();
    std::unique_ptr<ast::Type> make_compound_type(const std::string& name);
    
} // namespace type_utils

} // namespace logicpp#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <optional>
#include <variant>
#include <span>
#include <format>

namespace logicpp {

enum class TokenType {
    // Literals
    IDENTIFIER,
    INTEGER,
    FLOAT,
    STRING,
    ATOM,

    // Keywords
    FACT,
    RULE,
    QUERY,
    TYPE,
    FN,
    MATCH,
    WHERE,
    LET,

    // Operators
    RULE_OP,        // :-
    QUERY_OP,       // ?-
    ARROW,          // ->
    PIPE,           // |
    UNIFY,          // =
    NOT_UNIFY,      // \=
    LESS,           // <
    GREATER,        // >
    LESS_EQUAL,     // <=
    GREATER_EQUAL,  // >=
    EQUAL,          // ==
    NOT_EQUAL,      // !=

    // Delimiters
    LPAREN,         // (
    RPAREN,         // )
    LBRACE,         // {
    RBRACE,         // }
    LBRACKET,       // [
    RBRACKET,       // ]
    DOT,            // .
    COMMA,          // ,
    SEMICOLON,      // ;
    COLON,          // :
    UNDERSCORE,     // _

    // Special
    NEWLINE,
    EOF_TOKEN,
    INVALID
};

struct Position {
    size_t line = 1;
    size_t column = 1;
    size_t offset = 0;
};

struct Token {
    TokenType type;
    std::string value;
    Position position;

    Token(TokenType t, std::string v, Position pos) 
        : type(t), value(std::move(v)), position(pos) {}
};

class Lexer {
private:
    std::string_view source;
    size_t current_pos = 0;
    Position position;
    
    static const std::unordered_map<std::string, TokenType> keywords;

    char peek(size_t offset = 0) const noexcept;
    char advance() noexcept;
    void skip_whitespace() noexcept;
    void skip_comment() noexcept;
    
    Token make_token(TokenType type, std::string value) const;
    Token scan_identifier();
    Token scan_number();
    Token scan_string();
    Token scan_operator();

public:
    explicit Lexer(std::string_view source) : source(source) {}
    
    std::vector<Token> tokenize();
    Token next_token();
    
    // Utility methods
    bool at_end() const noexcept { return current_pos >= source.length(); }
    Position current_position() const noexcept { return position; }
};

// Token type to string conversion
std::string to_string(TokenType type);
std::ostream& operator<<(std::ostream& os, const Token& token);

} // namespace logicpp#pragma once

#include "lexer.hpp"
#include "ast.hpp"
#include <memory>
#include <vector>
#include <expected>
#include <string>

namespace logicpp {

class ParseError : public std::exception {
private:
    std::string message;
    Position position;

public:
    ParseError(std::string msg, Position pos) 
        : message(std::move(msg)), position(pos) {}
    
    const char* what() const noexcept override { return message.c_str(); }
    Position where() const noexcept { return position; }
};

class Parser {
private:
    std::vector<Token> tokens;
    size_t current_token = 0;
    
    // Token management
    const Token& peek(size_t offset = 0) const;
    const Token& advance();
    bool check(TokenType type) const;
    bool match(TokenType type);
    bool match(std::initializer_list<TokenType> types);
    const Token& consume(TokenType type, const std::string& error_msg);
    bool at_end() const;
    
    // Error handling
    void synchronize();
    [[noreturn]] void error(const std::string& message);
    
    // Parsing methods
    std::unique_ptr<ast::Program> parse_program();
    std::unique_ptr<ast::Clause> parse_clause();
    std::unique_ptr<ast::Fact> parse_fact();
    std::unique_ptr<ast::Rule> parse_rule();
    std::unique_ptr<ast::Query> parse_query();
    std::unique_ptr<ast::TypeDefinition> parse_type_definition();
    std::unique_ptr<ast::Function> parse_function();
    
    // Expression parsing
    std::unique_ptr<ast::Expression> parse_expression();
    std::unique_ptr<ast::Expression> parse_logical_or();
    std::unique_ptr<ast::Expression> parse_logical_and();
    std::unique_ptr<ast::Expression> parse_equality();
    std::unique_ptr<ast::Expression> parse_comparison();
    std::unique_ptr<ast::Expression> parse_unification();
    std::unique_ptr<ast::Expression> parse_primary_expression();
    
    // Term parsing
    std::unique_ptr<ast::Term> parse_term();
    std::unique_ptr<ast::Compound> parse_compound();
    std::unique_ptr<ast::Atom> parse_atom();
    std::unique_ptr<ast::Variable> parse_variable();
    std::unique_ptr<ast::Number> parse_number();
    std::unique_ptr<ast::String> parse_string();
    
    // Type parsing
    std::unique_ptr<ast::Type> parse_type();
    
    // Utility methods
    std::vector<std::unique_ptr<ast::Expression>> parse_where_clause();
    std::vector<std::unique_ptr<ast::Term>> parse_argument_list();
    
public:
    explicit Parser(std::vector<Token> tokens) : tokens(std::move(tokens)) {}
    
    std::expected<std::unique_ptr<ast::Program>, ParseError> parse();
    
    // Static utility for quick parsing
    static std::expected<std::unique_ptr<ast::Program>, ParseError> 
    parse_source(std::string_view source);
};

} // namespace logicpp