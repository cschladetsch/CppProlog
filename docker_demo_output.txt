# CppLProlog Docker Generator Demo Output
# This demonstrates how Prolog could generate Dockerfiles

## 1. Production Dockerfile Generated by Prolog Rules:

# CppLProlog Production Dockerfile
# Generated by Prolog Docker Generator
# Optimized for build caching and security

# ============================================
# Stage 1: Build Environment
# ============================================
FROM ubuntu:22.04 AS builder

# Install build dependencies (optimized layer caching)
RUN apt-get update && apt-get install -y build-essential cmake git ninja-build clang-15 && apt-get clean && rm -rf /var/lib/apt/lists/*

# Set up modern C++ environment
ENV CC=clang-15
ENV CXX=clang++-15
ENV CMAKE_BUILD_TYPE=Release

# Create build directory
WORKDIR /build

# Copy dependency files first (better layer caching)
COPY CMakeLists.txt .
COPY External/ External/

# Initialize git submodules
RUN git submodule update --init --recursive || true

# Copy source files
COPY src/ src/
COPY tests/ tests/
COPY examples/ examples/
COPY benchmarks/ benchmarks/

# Configure and build with optimization
RUN cmake -B build -G Ninja \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_CXX_COMPILER=clang++-15 \
    -DCMAKE_CXX_STANDARD=23 \
    && ninja -C build

# Run tests to ensure build quality
RUN cd build && ./bin/prolog_tests

# ============================================
# Stage 2: Production Runtime
# ============================================
FROM ubuntu:22.04 AS runtime

# Install minimal runtime dependencies
RUN apt-get update && apt-get install -y libc++1-15 libc++abi1-15 && apt-get clean && rm -rf /var/lib/apt/lists/*

# Security: Create non-root user
RUN groupadd -r prolog && useradd -r -g prolog prolog

# Create application directory
WORKDIR /app

# Copy built executables from builder stage
COPY --from=builder /build/build/bin/ ./bin/
COPY --from=builder /build/examples/*.pl ./examples/

# Set proper ownership
RUN chown -R prolog:prolog /app

# Switch to non-root user
USER prolog

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD ./bin/prolog_tests --gtest_filter="*Basic*" || exit 1

# Default command
CMD ["./bin/prolog_interpreter"]

## 2. Development Dockerfile Generated by Prolog Rules:

# CppLProlog Development Dockerfile
# Generated by Prolog Docker Generator
# Includes debugging tools and development environment

FROM ubuntu:22.04 AS development

# Install build and development dependencies
RUN apt-get update && apt-get install -y build-essential cmake git ninja-build clang-15 gdb valgrind vim && apt-get clean && rm -rf /var/lib/apt/lists/*

# Set up development environment
ENV CC=clang-15
ENV CXX=clang++-15
ENV CMAKE_BUILD_TYPE=Debug

# Keep source for development
WORKDIR /workspace
COPY . .

# Build debug version
RUN cmake -B build-debug -G Ninja \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_CXX_COMPILER=clang++-15 \
    && ninja -C build-debug

# Development command
CMD ["/bin/bash"]

## 3. Prolog Logic Behind Generation:

The Prolog system uses declarative rules to:

1. **Select optimal base images** based on requirements:
   ```prolog
   optimal_base_image(cpp_build, 'ubuntu:22.04').
   optimal_base_image(minimal_runtime, 'ubuntu:22.04').
   ```

2. **Define package dependencies**:
   ```prolog
   essential_build_packages(['build-essential', 'cmake', 'git', 'ninja-build', 'clang-15']).
   essential_runtime_packages(['libc++1-15', 'libc++abi1-15']).
   ```

3. **Apply optimization strategies**:
   ```prolog
   cache_optimized_layers(Stage, Instructions) :-
       Stage = builder,
       Instructions = [
           copy('CMakeLists.txt', '.'),     % Dependencies first
           copy('External/', 'External/'),
           copy('src/', 'src/')             % Source last
       ].
   ```

4. **Security hardening**:
   ```prolog
   security_optimized(Instructions) :-
       Instructions = [
           run('groupadd -r prolog && useradd -r -g prolog prolog'),
           user('prolog')
       ].
   ```

## 4. Benefits of Prolog-Generated Dockerfiles:

✅ **Consistency**: All Dockerfiles follow the same patterns
✅ **Optimization**: Automatic layer caching optimization  
✅ **Security**: Built-in security best practices
✅ **Maintainability**: Change rules once, update all Dockerfiles
✅ **Validation**: Automatic validation of Docker instructions
✅ **Flexibility**: Easy to generate variants (dev, prod, CI)

## 5. Example Prolog Queries for Docker Generation:

```prolog
% Generate production Dockerfile
?- generate_production_dockerfile.

% Generate development Dockerfile  
?- generate_development_dockerfile.

% Check security compliance
?- production_strategy(S), has_security_user(S).

% Estimate build time
?- production_strategy(S), estimate_build_time(S, Time).

% Validate instructions
?- validate_dockerfile_syntax([from('ubuntu:22.04'), run('apt-get update')]).
```

This demonstrates how Prolog's declarative nature makes it excellent for:
- Infrastructure as Code
- Policy enforcement
- Automated optimization
- Compliance checking
- Template generation with variations